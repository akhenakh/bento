"use strict";(self.webpackChunkbento=self.webpackChunkbento||[]).push([[3691],{2352:function(e,n,s){s.r(n),s.d(n,{assets:function(){return p},contentTitle:function(){return a},default:function(){return u},frontMatter:function(){return r},metadata:function(){return i},toc:function(){return c}});var t=s(5893),o=s(1151);const r={title:"Synchronous Responses"},a=void 0,i={id:"guides/sync_responses",title:"Synchronous Responses",description:"In a regular Bento pipeline messages will flow in one direction and acknowledgements flow in the other:",source:"@site/docs/guides/sync_responses.md",sourceDirName:"guides",slug:"/guides/sync_responses",permalink:"/bento/docs/guides/sync_responses",draft:!1,unlisted:!1,editUrl:"https://github.com/warpstreamlabs/bento/edit/main/website/docs/guides/sync_responses.md",tags:[],version:"current",frontMatter:{title:"Synchronous Responses"},sidebar:"docs",previous:{title:"Performance Tuning",permalink:"/bento/docs/guides/performance_tuning"},next:{title:"Amazon Web Services",permalink:"/bento/docs/guides/cloud/aws"}},p={},c=[{value:"Routing Processed Messages Back",id:"routing-processed-messages-back",level:2},{value:"Returning Partially Processed Messages",id:"returning-partially-processed-messages",level:2},{value:"Routing Output Responses Back",id:"routing-output-responses-back",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"In a regular Bento pipeline messages will flow in one direction and acknowledgements flow in the other:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"    ----------- Message -------------\x3e\n\nInput (AMQP) -> Processors -> Output (AMQP)\n\n    <------- Acknowledgement ---------\n"})}),"\n",(0,t.jsx)(n.p,{children:"However, Bento has support for a number of protocols where this limitation is not the case."}),"\n",(0,t.jsxs)(n.p,{children:["For example, HTTP is a request/response protocol, and so our ",(0,t.jsx)(n.code,{children:"http_server"})," input is capable of returning a response payload after consuming a message from a request."]}),"\n",(0,t.jsx)(n.p,{children:"When using these protocols it's possible to configure Bento stream pipelines that allow messages to pass in the opposite direction, resulting in response messages at the input level:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",children:"           --------- Request Body --------\x3e\n\nInput (HTTP Server) -> Processors -> Output (Sync Response)\n\n           <--- Response Body (and ack) ---\n"})}),"\n",(0,t.jsx)(n.h2,{id:"routing-processed-messages-back",children:"Routing Processed Messages Back"}),"\n",(0,t.jsxs)(n.p,{children:["It's possible to route the result of any Bento processing pipeline directly back to an input with a ",(0,t.jsx)(n.a,{href:"/docs/components/outputs/sync_response",children:(0,t.jsx)(n.code,{children:"sync_response"})})," output:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"input:\n  http_server:\n    path: /post\npipeline:\n  processors:\n    - mapping: root = content().uppercase()\noutput:\n  sync_response: {}\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Using the above example, sending a request 'foo bar' to the path ",(0,t.jsx)(n.code,{children:"/post"})," returns the response 'FOO BAR'."]}),"\n",(0,t.jsxs)(n.p,{children:["It's also possible to combine a ",(0,t.jsx)(n.code,{children:"sync_response"})," output with other outputs using a ",(0,t.jsx)(n.a,{href:"/docs/components/outputs/broker",children:(0,t.jsx)(n.code,{children:"broker"})}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"input:\n  http_server:\n    path: /post\noutput:\n  broker:\n    pattern: fan_out\n    outputs:\n      - kafka:\n          addresses: [ TODO:9092 ]\n          topic: foo_topic\n      - sync_response: {}\n        processors:\n          - mapping: root = content().uppercase()\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Using the above example, sending a request 'foo bar' to the path ",(0,t.jsx)(n.code,{children:"/post"})," passes the message unchanged to the Kafka topic ",(0,t.jsx)(n.code,{children:"foo_topic"})," and also returns the response 'FOO BAR'."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"It's safe to use these mechanisms even when combining multiple inputs with a broker, a response payload will always be routed back to the original source of the message."})}),"\n",(0,t.jsx)(n.h2,{id:"returning-partially-processed-messages",children:"Returning Partially Processed Messages"}),"\n",(0,t.jsxs)(n.p,{children:["It's possible to set the state of a message to be the synchronous response before processing is finished by using the ",(0,t.jsxs)(n.a,{href:"/docs/components/processors/sync_response",children:[(0,t.jsx)(n.code,{children:"sync_response"})," processor"]}),". This allows you to further mutate the payload without changing the response returned to the input:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'input:\n  http_server:\n    path: /post\n\npipeline:\n  processors:\n    - mapping: root = "%v baz".format(content().string())\n    - sync_response: {}\n    - mapping: root = content().uppercase()\n\noutput:\n  kafka:\n    addresses: [ TODO:9092 ]\n    topic: foo_topic\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Using the above example, sending a request 'foo bar' to the path ",(0,t.jsx)(n.code,{children:"/post"})," passes the message 'FOO BAR BAZ' to the Kafka topic ",(0,t.jsx)(n.code,{children:"foo_topic"}),", and also returns the response 'foo bar baz'."]}),"\n",(0,t.jsx)(n.p,{children:"However, it is important to keep in mind that due to Bento' strict delivery guarantees the response message will not actually be returned until the message has reached its output destination and an acknowledgement can be made."}),"\n",(0,t.jsx)(n.h2,{id:"routing-output-responses-back",children:"Routing Output Responses Back"}),"\n",(0,t.jsxs)(n.p,{children:["Some outputs, such as ",(0,t.jsx)(n.a,{href:"/docs/components/outputs/http_client",children:(0,t.jsx)(n.code,{children:"http_client"})}),", have the potential to propagate payloads received from their destination after sending a message back to the input:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"input:\n  http_server:\n    path: /post\noutput:\n  http_client:\n    url: http://localhost:4196/post\n    verb: POST\n    propagate_response: true\n"})}),"\n",(0,t.jsxs)(n.p,{children:["With the above example a message received from the endpoint ",(0,t.jsx)(n.code,{children:"/post"})," would be sent unchanged to the address ",(0,t.jsx)(n.code,{children:"http://localhost:4196/post"}),", and then the response from that request would get returned back. This basically turns Bento into a proxy server with the potential to mutate payloads between requests."]}),"\n",(0,t.jsx)(n.p,{children:"The following config turns Bento into an HTTP proxy server that also sends all request payloads to a Kafka topic:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"input:\n  http_server:\n    path: /post\noutput:\n  broker:\n    pattern: fan_out\n    outputs:\n      - kafka:\n          addresses: [ TODO:9092 ]\n          topic: foo_topic\n      - http_client:\n          url: http://localhost:4196/post\n          verb: POST\n          propagate_response: true\n"})})]})}function u(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},1151:function(e,n,s){s.d(n,{Z:function(){return i},a:function(){return a}});var t=s(7294);const o={},r=t.createContext(o);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);