"use strict";(self.webpackChunkbento=self.webpackChunkbento||[]).push([[9075],{15:function(e,n,o){o.r(n),o.d(n,{assets:function(){return l},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return a},metadata:function(){return r},toc:function(){return c}});var t=o(85893),i=o(11151);const a={title:"Interpolation"},s=void 0,r={id:"configuration/interpolation",title:"Interpolation",description:"Bento allows you to dynamically set config fields with environment variables anywhere within a config file using the syntax ${} (or ${",source:"@site/docs/configuration/interpolation.md",sourceDirName:"configuration",slug:"/configuration/interpolation",permalink:"/bento/docs/configuration/interpolation",draft:!1,unlisted:!1,editUrl:"https://github.com/warpstreamlabs/bento/edit/main/website/docs/configuration/interpolation.md",tags:[],version:"current",frontMatter:{title:"Interpolation"},sidebar:"docs",previous:{title:"Error Handling",permalink:"/bento/docs/configuration/error_handling"},next:{title:"Secrets",permalink:"/bento/docs/configuration/secrets"}},l={},c=[{value:"Undefined Variables",id:"undefined-variables",level:3},{value:"Bloblang Queries",id:"bloblang-queries",level:2},{value:"Examples",id:"examples",level:2},{value:"Reference Metadata",id:"reference-metadata",level:3},{value:"Coalesce and Mapping",id:"coalesce-and-mapping",level:3},{value:"Delayed Processing",id:"delayed-processing",level:3}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["Bento allows you to dynamically set config fields with environment variables anywhere within a config file using the syntax ",(0,t.jsx)(n.code,{children:"${<variable-name>}"})," (or ",(0,t.jsx)(n.code,{children:"${<variable-name>:<default-value>}"})," in order to specify a default value). This is useful for setting environment specific fields such as addresses:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'input:\n  kafka:\n    addresses: [ "${BROKERS}" ]\n    consumer_group: bento_bridge_consumer\n    topics: [ "haha_business" ]\n'})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-sh",children:'BROKERS="foo:9092,bar:9092" bento -c ./config.yaml\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If a literal string is required that matches this pattern (",(0,t.jsx)(n.code,{children:"${foo}"}),") you can escape it with double brackets. For example, the string ",(0,t.jsx)(n.code,{children:"${{foo}}"})," is read as the literal ",(0,t.jsx)(n.code,{children:"${foo}"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"undefined-variables",children:"Undefined Variables"}),"\n",(0,t.jsxs)(n.p,{children:["When an environment variable interpolation is found within a config, does not have a default value specified, and the environment variable is not defined a linting error will be reported. In order to avoid this it is possible to specify environment variable interpolations with an explicit empty default value by adding the colon without a following value, i.e. ",(0,t.jsx)(n.code,{children:"${FOO:}"})," would be equivalent to ",(0,t.jsx)(n.code,{children:"${FOO}"})," and would not trigger a linting error should ",(0,t.jsx)(n.code,{children:"FOO"})," not be defined."]}),"\n",(0,t.jsx)(n.h2,{id:"bloblang-queries",children:"Bloblang Queries"}),"\n",(0,t.jsxs)(n.p,{children:["Some Bento fields also support ",(0,t.jsx)(n.a,{href:"/docs/guides/bloblang/about",children:"Bloblang"})," function interpolations, which are much more powerful expressions that allow you to query the contents of messages and perform arithmetic. The syntax of a function interpolation is ",(0,t.jsx)(n.code,{children:"${!<bloblang expression>}"}),", where the contents are a bloblang query (the right-hand-side of a bloblang map) including a range of ",(0,t.jsx)(n.a,{href:"/docs/guides/bloblang/about#functions",children:"functions"}),". For example, with the following config:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'output:\n  kafka:\n    addresses: [ "TODO:6379" ]\n    topic: \'meow-${! json("topic") }\'\n'})}),"\n",(0,t.jsxs)(n.p,{children:["A message with the contents ",(0,t.jsx)(n.code,{children:'{"topic":"foo","message":"hello world"}'})," would be routed to the Kafka topic ",(0,t.jsx)(n.code,{children:"meow-foo"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["If a literal string is required that matches this pattern (",(0,t.jsx)(n.code,{children:"${!foo}"}),") then, similar to environment variables, you can escape it with double brackets. For example, the string ",(0,t.jsx)(n.code,{children:"${{!foo}}"})," would be read as the literal ",(0,t.jsx)(n.code,{children:"${!foo}"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Bloblang supports arithmetic, boolean operators, coalesce and mapping expressions. For more in-depth details about the language ",(0,t.jsx)(n.a,{href:"/docs/guides/bloblang/about",children:"check out the docs"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,t.jsx)(n.h3,{id:"reference-metadata",children:"Reference Metadata"}),"\n",(0,t.jsx)(n.p,{children:"A common usecase for interpolated functions is dynamic routing at the output level using metadata:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'output:\n  kafka:\n    addresses: [ TODO ]\n    topic: ${! meta("output_topic") }\n    key: ${! meta("key") }\n'})}),"\n",(0,t.jsx)(n.h3,{id:"coalesce-and-mapping",children:"Coalesce and Mapping"}),"\n",(0,t.jsx)(n.p,{children:"Bloblang supports coalesce and mapping, which makes it easy to extract values from slightly varying data structures:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"pipeline:\n  processors:\n    - cache:\n        resource: foocache\n        operator: set\n        key: '${! json().message.(foo | bar).id }'\n        value: '${! content() }'\n"})}),"\n",(0,t.jsx)(n.p,{children:"Here's a map of inputs to resulting values:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'{"foo":{"a":{"baz":"from_a"},"c":{"baz":"from_c"}}} -> from_a\n{"foo":{"b":{"baz":"from_b"},"c":{"baz":"from_c"}}} -> from_b\n{"foo":{"b":null,"c":{"baz":"from_c"}}}             -> from_c\n'})}),"\n",(0,t.jsx)(n.h3,{id:"delayed-processing",children:"Delayed Processing"}),"\n",(0,t.jsxs)(n.p,{children:["We have a stream of JSON documents each with a unix timestamp field ",(0,t.jsx)(n.code,{children:"doc.received_at"})," which is set when our platform receives it. We wish to only process messages an hour ",(0,t.jsx)(n.em,{children:"after"})," they were received. We can achieve this by running the ",(0,t.jsx)(n.code,{children:"sleep"})," processor using an interpolation function to calculate the seconds needed to wait for:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"pipeline:\n  processors:\n  - sleep:\n      duration: '${! 3600 - ( timestamp_unix() - json(\"doc.created_at\").number() ) }s'\n"})}),"\n",(0,t.jsxs)(n.p,{children:["If the calculated result is less than or equal to zero the processor does not sleep at all. If the value of ",(0,t.jsx)(n.code,{children:"doc.created_at"})," is a string then our method ",(0,t.jsx)(n.code,{children:".number()"})," will attempt to parse it into a number."]})]})}function u(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},11151:function(e,n,o){o.d(n,{Z:function(){return r},a:function(){return s}});var t=o(67294);const i={},a=t.createContext(i);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);