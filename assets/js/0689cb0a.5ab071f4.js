"use strict";(self.webpackChunkbento=self.webpackChunkbento||[]).push([[2956],{9709:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return i},default:function(){return h},frontMatter:function(){return s},metadata:function(){return r},toc:function(){return l}});var a=t(5893),o=t(1151);const s={title:"Advanced Bloblang",sidebar_label:"Advanced",description:"Some advanced Bloblang patterns"},i=void 0,r={id:"guides/bloblang/advanced",title:"Advanced Bloblang",description:"Some advanced Bloblang patterns",source:"@site/docs/guides/bloblang/advanced.md",sourceDirName:"guides/bloblang",slug:"/guides/bloblang/advanced",permalink:"/bento/docs/guides/bloblang/advanced",draft:!1,unlisted:!1,editUrl:"https://github.com/warpstreamlabs/bento/edit/main/website/docs/guides/bloblang/advanced.md",tags:[],version:"current",frontMatter:{title:"Advanced Bloblang",sidebar_label:"Advanced",description:"Some advanced Bloblang patterns"},sidebar:"docs",previous:{title:"Arithmetic",permalink:"/bento/docs/guides/bloblang/arithmetic"},next:{title:"Monitoring",permalink:"/bento/docs/guides/monitoring"}},c={},l=[{value:"Map Parameters",id:"map-parameters",level:2},{value:"Walking the Tree",id:"walking-the-tree",level:2},{value:"Message Expansion",id:"message-expansion",level:2},{value:"Creating CSV",id:"creating-csv",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h2,{id:"map-parameters",children:"Map Parameters"}),"\n",(0,a.jsx)(n.p,{children:"A map definition only has one input parameter, which is the context that it is called upon:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coffee",children:'map formatting {\n  root = "(%v)".format(this)\n}\n\nroot.a = this.a.apply("formatting")\nroot.b = this.b.apply("formatting")\n\n# In:  {"a":"foo","b":"bar"}\n# Out: {"a":"(foo)","b":"(bar)"}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["However, we can use object literals in order to provide multiple map parameters. Imagine if we wanted a map that is the exact same as above except the pattern is ",(0,a.jsx)(n.code,{children:"[%v]"})," instead, with the potential for even more patterns in the future. To do that we can pass an object with a field ",(0,a.jsx)(n.code,{children:"value"})," with our target to map and a field ",(0,a.jsx)(n.code,{children:"pattern"})," which allows us to specify the pattern to apply:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coffee",children:'map formatting {\n  root = this.pattern.format(this.value)\n}\n\nroot.a = {\n  "value":this.a,\n  "pattern":this.pattern,\n}.apply("formatting")\n\nroot.b = {\n  "value":this.b,\n  "pattern":this.pattern,\n}.apply("formatting")\n\n# In:  {"a":"foo","b":"bar","pattern":"[%v]"}\n# Out: {"a":"[foo]","b":"[bar]"}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"walking-the-tree",children:"Walking the Tree"}),"\n",(0,a.jsx)(n.p,{children:"Sometimes it's necessary to perform a mapping on all values within an unknown tree structure. You can do that easily with recursive mapping:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coffee",children:'map unescape_values {\n  root = match {\n    this.type() == "object" => this.map_each(item -> item.value.apply("unescape_values")),\n    this.type() == "array" => this.map_each(ele -> ele.apply("unescape_values")),\n    this.type() == "string" => this.unescape_html(),\n    this.type() == "bytes" => this.unescape_html(),\n    _ => this,\n  }\n}\nroot = this.apply("unescape_values")\n\n# In:  {"first":{"nested":"foo &amp; bar"},"second":10,"third":["1 &lt; 2",{"also_nested":"2 &gt; 1"}]}\n# Out: {"first":{"nested":"foo & bar"},"second":10,"third":["1 < 2",{"also_nested":"2 > 1"}]}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"message-expansion",children:"Message Expansion"}),"\n",(0,a.jsxs)(n.p,{children:["Expanding a single message into multiple messages can be done by mapping messages into an array and following it up with an ",(0,a.jsxs)(n.a,{href:"/docs/components/processors/unarchive",children:[(0,a.jsx)(n.code,{children:"unarchive"})," processor"]}),". For example, given documents of this format:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-json",children:'{\n  "id": "foobar",\n  "items": [\n    {"content":"foo"},\n    {"content":"bar"},\n    {"content":"baz"}\n  ]\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["We can pull ",(0,a.jsx)(n.code,{children:"items"})," out to the root with ",(0,a.jsx)(n.code,{children:"root = items"})," with a ",(0,a.jsxs)(n.a,{href:"/docs/components/processors/mapping",children:[(0,a.jsx)(n.code,{children:"mapping"})," processor"]})," and follow it with an ",(0,a.jsxs)(n.a,{href:"/docs/components/processors/unarchive",children:[(0,a.jsx)(n.code,{children:"unarchive"})," processor"]})," to expand each element into its own independent message:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"pipeline:\n  processors:\n    - mapping: root = this.items\n    - unarchive:\n        format: json_array\n"})}),"\n",(0,a.jsxs)(n.p,{children:["However, most of the time we also need to map the elements before expanding them, and often that includes copying fields outside of our target array. We can do that with methods such as ",(0,a.jsx)(n.code,{children:"map_each"})," and ",(0,a.jsx)(n.code,{children:"merge"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coffee",children:'root = this.items.map_each(ele -> this.without("items").merge(ele))\n\n# In:  {"id":"foobar","items":[{"content":"foo"},{"content":"bar"},{"content":"baz"}]}\n# Out: [{"content":"foo","id":"foobar"},{"content":"bar","id":"foobar"},{"content":"baz","id":"foobar"}]\n'})}),"\n",(0,a.jsxs)(n.p,{children:["However, the above mapping is slightly inefficient as we would create a copy of our source object for each element with the ",(0,a.jsx)(n.code,{children:'this.without("items")'})," part. A more efficient way to do this would be to capture that query within a variable:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coffee",children:'let doc_root = this.without("items")\nroot = this.items.map_each($doc_root.merge(this))\n\n# In:  {"id":"foobar","items":[{"content":"foo"},{"content":"bar"},{"content":"baz"}]}\n# Out: [{"content":"foo","id":"foobar"},{"content":"bar","id":"foobar"},{"content":"baz","id":"foobar"}]\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Also note that when we set ",(0,a.jsx)(n.code,{children:"doc_root"})," we remove the field ",(0,a.jsx)(n.code,{children:"items"})," from the target document. The full config would now be:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'pipeline:\n  processors:\n    - mapping: |\n        let doc_root = this.without("items")\n        root = this.items.map_each($doc_root.merge(this))\n    - unarchive:\n        format: json_array\n'})}),"\n",(0,a.jsx)(n.h2,{id:"creating-csv",children:"Creating CSV"}),"\n",(0,a.jsx)(n.p,{children:"Bento has a few different ways of outputting a stream of CSV data. However, the best way to do it is by converting the documents into CSV rows with Bloblang as this gives you full control over exactly how the schema is generated, erroneous data is handled, and escaping of column data is performed."}),"\n",(0,a.jsxs)(n.p,{children:["A common and simple use case is to simply flatten documents and write out the column values in alphabetical order. The first row we generate should also be prefixed with a row containing those column names. Here's a mapping that achieves this by using a ",(0,a.jsx)(n.code,{children:"count"})," function to detect the very first invocation of the mapping in a stream pipeline:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-coffee",children:'map escape_csv {\n  root = if this.re_match("[\\"\\n,]+") {\n    "\\"" + this.replace_all("\\"", "\\"\\"") + "\\""\n  } else {\n    this\n  }\n}\n\n# Extract key/value pairs as an array and sort by the key\nlet kvs = this.key_values().sort_by(v -> v.key)\n\n# Create a header prefix for our output only on the first row\nlet header = if count("rows_in_file") == 1 {\n  $kvs.map_each(kv -> kv.key.apply("escape_csv")).join(",") + "\\n"\n} else { "" }\n\nroot = $header + $kvs.map_each(kv -> kv.value.string().apply("escape_csv")).join(",")\n'})}),"\n",(0,a.jsxs)(n.p,{children:["And with this mapping we can write the data to a newly created CSV file using an output with a simple ",(0,a.jsx)(n.code,{children:"lines"})," codec:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"output:\n  file:\n    path: ./result.csv\n    codec: lines\n"})}),"\n",(0,a.jsx)(n.p,{children:"Perhaps the first expansion of this mapping that would be worthwhile is to add an explicit list of column names, or at least confirm that the number of values in a row matches an expected count."})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},1151:function(e,n,t){t.d(n,{Z:function(){return r},a:function(){return i}});var a=t(7294);const o={},s=a.createContext(o);function i(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);