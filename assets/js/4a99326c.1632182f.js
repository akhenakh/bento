"use strict";(self.webpackChunkbento=self.webpackChunkbento||[]).push([[9166],{25246:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return o},metadata:function(){return d},toc:function(){return u}});var s=t(85893),a=t(11151),r=t(74866),i=t(85162);const o={title:"sequence",slug:"sequence",type:"input",status:"stable",categories:["Utility"],name:"sequence"},l=void 0,d={id:"components/inputs/sequence",title:"sequence",description:"\x3c!--",source:"@site/docs/components/inputs/sequence.md",sourceDirName:"components/inputs",slug:"/components/inputs/sequence",permalink:"/bento/docs/components/inputs/sequence",draft:!1,unlisted:!1,editUrl:"https://github.com/warpstreamlabs/bento/edit/main/website/docs/components/inputs/sequence.md",tags:[],version:"current",frontMatter:{title:"sequence",slug:"sequence",type:"input",status:"stable",categories:["Utility"],name:"sequence"},sidebar:"docs",previous:{title:"resource",permalink:"/bento/docs/components/inputs/resource"},next:{title:"sftp",permalink:"/bento/docs/components/inputs/sftp"}},c={},u=[{value:"Examples",id:"examples",level:2},{value:"Fields",id:"fields",level:2},{value:"<code>sharded_join</code>",id:"sharded_join",level:3},{value:"<code>sharded_join.type</code>",id:"sharded_jointype",level:3},{value:"<code>sharded_join.id_path</code>",id:"sharded_joinid_path",level:3},{value:"<code>sharded_join.iterations</code>",id:"sharded_joiniterations",level:3},{value:"<code>sharded_join.merge_strategy</code>",id:"sharded_joinmerge_strategy",level:3},{value:"<code>inputs</code>",id:"inputs",level:3}];function h(e){const n={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:"Reads messages from a sequence of child inputs, starting with the first and once that input gracefully terminates starts consuming from the next, and so on."}),"\n",(0,s.jsxs)(r.Z,{defaultValue:"common",values:[{label:"Common",value:"common"},{label:"Advanced",value:"advanced"}],children:[(0,s.jsx)(i.Z,{value:"common",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yml",children:'# Common config fields, showing default values\ninput:\n  label: ""\n  sequence:\n    inputs: [] # No default (required)\n'})})}),(0,s.jsx)(i.Z,{value:"advanced",children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yml",children:'# All config fields, showing default values\ninput:\n  label: ""\n  sequence:\n    sharded_join:\n      type: none\n      id_path: ""\n      iterations: 1\n      merge_strategy: array\n    inputs: [] # No default (required)\n'})})})]}),"\n",(0,s.jsx)(n.p,{children:"This input is useful for consuming from inputs that have an explicit end but must not be consumed in parallel."}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsxs)(r.Z,{defaultValue:"End of Stream Message",values:[{label:"End of Stream Message",value:"End of Stream Message"},{label:"Joining Data (Simple)",value:"Joining Data (Simple)"},{label:"Joining Data (Advanced)",value:"Joining Data (Advanced)"}],children:[(0,s.jsxs)(i.Z,{value:"End of Stream Message",children:[(0,s.jsxs)(n.p,{children:["A common use case for sequence might be to generate a message at the end of our main input. With the following config once the records within ",(0,s.jsx)(n.code,{children:"./dataset.csv"})," are exhausted our final payload ",(0,s.jsx)(n.code,{children:'{"status":"finished"}'})," will be routed through the pipeline."]}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'input:\n  sequence:\n    inputs:\n      - file:\n          paths: [ ./dataset.csv ]\n          scanner:\n            csv: {}\n      - generate:\n          count: 1\n          mapping: \'root = {"status":"finished"}\'\n'})})]}),(0,s.jsxs)(i.Z,{value:"Joining Data (Simple)",children:[(0,s.jsx)(n.p,{children:'Bento can be used to join unordered data from fragmented datasets in memory by specifying a common identifier field and a number of sharded iterations. For example, given two CSV files, the first called "main.csv", which contains rows of user data:'}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csv",children:"uuid,name,age\nAAA,Melanie,34\nBBB,Emma,28\nCCC,Geri,45\n"})}),(0,s.jsx)(n.p,{children:'And the second called "hobbies.csv" that, for each user, contains zero or more rows of hobbies:'}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csv",children:"uuid,hobby\nCCC,pokemon go\nAAA,rowing\nAAA,golf\n"})}),(0,s.jsx)(n.p,{children:"We can parse and join this data into a single dataset:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{"uuid":"AAA","name":"Melanie","age":34,"hobbies":["rowing","golf"]}\n{"uuid":"BBB","name":"Emma","age":28}\n{"uuid":"CCC","name":"Geri","age":45,"hobbies":["pokemon go"]}\n'})}),(0,s.jsx)(n.p,{children:"With the following config:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"input:\n  sequence:\n    sharded_join:\n      type: full-outer\n      id_path: uuid\n      merge_strategy: array\n    inputs:\n      - file:\n          paths:\n            - ./hobbies.csv\n            - ./main.csv\n          scanner:\n            csv: {}\n"})})]}),(0,s.jsxs)(i.Z,{value:"Joining Data (Advanced)",children:[(0,s.jsx)(n.p,{children:"In this example we are able to join unordered and fragmented data from a combination of CSV files and newline-delimited JSON documents by specifying multiple sequence inputs with their own processors for extracting the structured data."}),(0,s.jsx)(n.p,{children:'The first file "main.csv" contains straight forward CSV data:'}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-csv",children:"uuid,name,age\nAAA,Melanie,34\nBBB,Emma,28\nCCC,Geri,45\n"})}),(0,s.jsx)(n.p,{children:'And the second file called "hobbies.ndjson" contains JSON documents, one per line, that associate an identifier with an array of hobbies. However, these data objects are in a nested format:'}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{"document":{"uuid":"CCC","hobbies":[{"type":"pokemon go"}]}}\n{"document":{"uuid":"AAA","hobbies":[{"type":"rowing"},{"type":"golf"}]}}\n'})}),(0,s.jsx)(n.p,{children:"And so we will want to map these into a flattened structure before the join, and then we will end up with a single dataset that looks like this:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{"uuid":"AAA","name":"Melanie","age":34,"hobbies":["rowing","golf"]}\n{"uuid":"BBB","name":"Emma","age":28}\n{"uuid":"CCC","name":"Geri","age":45,"hobbies":["pokemon go"]}\n'})}),(0,s.jsx)(n.p,{children:"With the following config:"}),(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"input:\n  sequence:\n    sharded_join:\n      type: full-outer\n      id_path: uuid\n      iterations: 10\n      merge_strategy: array\n    inputs:\n      - file:\n          paths: [ ./main.csv ]\n          scanner:\n            csv: {}\n      - file:\n          paths: [ ./hobbies.ndjson ]\n          scanner:\n            lines: {}\n        processors:\n          - mapping: |\n              root.uuid = this.document.uuid\n              root.hobbies = this.document.hobbies.map_each(this.type)\n"})})]})]}),"\n",(0,s.jsx)(n.h2,{id:"fields",children:"Fields"}),"\n",(0,s.jsx)(n.h3,{id:"sharded_join",children:(0,s.jsx)(n.code,{children:"sharded_join"})}),"\n",(0,s.jsx)(n.p,{children:"EXPERIMENTAL: Provides a way to perform outer joins of arbitrarily structured and unordered data resulting from the input sequence, even when the overall size of the data surpasses the memory available on the machine."}),"\n",(0,s.jsx)(n.p,{children:"When configured the sequence of inputs will be consumed one or more times according to the number of iterations, and when more than one iteration is specified each iteration will process an entirely different set of messages by sharding them by the ID field. Increasing the number of iterations reduces the memory consumption at the cost of needing to fully parse the data each time."}),"\n",(0,s.jsx)(n.p,{children:"Each message must be structured (JSON or otherwise processed into a structured form) and the fields will be aggregated with those of other messages sharing the ID. At the end of each iteration the joined messages are flushed downstream before the next iteration begins, hence keeping memory usage limited."}),"\n",(0,s.jsxs)(n.p,{children:["Type: ",(0,s.jsx)(n.code,{children:"object"}),(0,s.jsx)(n.br,{}),"\n","Requires version 3.40.0 or newer"]}),"\n",(0,s.jsx)(n.h3,{id:"sharded_jointype",children:(0,s.jsx)(n.code,{children:"sharded_join.type"})}),"\n",(0,s.jsxs)(n.p,{children:["The type of join to perform. A ",(0,s.jsx)(n.code,{children:"full-outer"})," ensures that all identifiers seen in any of the input sequences are sent, and is performed by consuming all input sequences before flushing the joined results. An ",(0,s.jsx)(n.code,{children:"outer"})," join consumes all input sequences but only writes data joined from the last input in the sequence, similar to a left or right outer join. With an ",(0,s.jsx)(n.code,{children:"outer"})," join if an identifier appears multiple times within the final sequence input it will be flushed each time it appears. ",(0,s.jsx)(n.code,{children:"full-outter"})," and ",(0,s.jsx)(n.code,{children:"outter"})," have been deprecated in favour of ",(0,s.jsx)(n.code,{children:"full-outer"})," and ",(0,s.jsx)(n.code,{children:"outer"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Type: ",(0,s.jsx)(n.code,{children:"string"}),(0,s.jsx)(n.br,{}),"\n","Default: ",(0,s.jsx)(n.code,{children:'"none"'}),(0,s.jsx)(n.br,{}),"\n","Options: ",(0,s.jsx)(n.code,{children:"none"}),", ",(0,s.jsx)(n.code,{children:"full-outer"}),", ",(0,s.jsx)(n.code,{children:"outer"}),", ",(0,s.jsx)(n.code,{children:"full-outter"}),", ",(0,s.jsx)(n.code,{children:"outter"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"sharded_joinid_path",children:(0,s.jsx)(n.code,{children:"sharded_join.id_path"})}),"\n",(0,s.jsxs)(n.p,{children:["A ",(0,s.jsx)(n.a,{href:"/docs/configuration/field_paths",children:"dot path"})," that points to a common field within messages of each fragmented data set and can be used to join them. Messages that are not structured or are missing this field will be dropped. This field must be set in order to enable joins."]}),"\n",(0,s.jsxs)(n.p,{children:["Type: ",(0,s.jsx)(n.code,{children:"string"}),(0,s.jsx)(n.br,{}),"\n","Default: ",(0,s.jsx)(n.code,{children:'""'})]}),"\n",(0,s.jsx)(n.h3,{id:"sharded_joiniterations",children:(0,s.jsx)(n.code,{children:"sharded_join.iterations"})}),"\n",(0,s.jsx)(n.p,{children:"The total number of iterations (shards), increasing this number will increase the overall time taken to process the data, but reduces the memory used in the process. The real memory usage required is significantly higher than the real size of the data and therefore the number of iterations should be at least an order of magnitude higher than the available memory divided by the overall size of the dataset."}),"\n",(0,s.jsxs)(n.p,{children:["Type: ",(0,s.jsx)(n.code,{children:"int"}),(0,s.jsx)(n.br,{}),"\n","Default: ",(0,s.jsx)(n.code,{children:"1"})]}),"\n",(0,s.jsx)(n.h3,{id:"sharded_joinmerge_strategy",children:(0,s.jsx)(n.code,{children:"sharded_join.merge_strategy"})}),"\n",(0,s.jsxs)(n.p,{children:["The chosen strategy to use when a data join would otherwise result in a collision of field values. The strategy ",(0,s.jsx)(n.code,{children:"array"})," means non-array colliding values are placed into an array and colliding arrays are merged. The strategy ",(0,s.jsx)(n.code,{children:"replace"})," replaces old values with new values. The strategy ",(0,s.jsx)(n.code,{children:"keep"})," keeps the old value."]}),"\n",(0,s.jsxs)(n.p,{children:["Type: ",(0,s.jsx)(n.code,{children:"string"}),(0,s.jsx)(n.br,{}),"\n","Default: ",(0,s.jsx)(n.code,{children:'"array"'}),(0,s.jsx)(n.br,{}),"\n","Options: ",(0,s.jsx)(n.code,{children:"array"}),", ",(0,s.jsx)(n.code,{children:"replace"}),", ",(0,s.jsx)(n.code,{children:"keep"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"inputs",children:(0,s.jsx)(n.code,{children:"inputs"})}),"\n",(0,s.jsx)(n.p,{children:"An array of inputs to read from sequentially."}),"\n",(0,s.jsxs)(n.p,{children:["Type: ",(0,s.jsx)(n.code,{children:"array"})]})]})}function p(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},85162:function(e,n,t){t.d(n,{Z:function(){return i}});t(67294);var s=t(86010),a={tabItem:"tabItem_Ymn6"},r=t(85893);function i(e){let{children:n,hidden:t,className:i}=e;return(0,r.jsx)("div",{role:"tabpanel",className:(0,s.Z)(a.tabItem,i),hidden:t,children:n})}},74866:function(e,n,t){t.d(n,{Z:function(){return w}});var s=t(67294),a=t(86010),r=t(12466),i=t(16550),o=t(20469),l=t(91980),d=t(67392),c=t(50012);function u(e){var n,t;return null!=(n=null==(t=s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}function h(e){const{values:n,children:t}=e;return(0,s.useMemo)((()=>{const e=null!=n?n:function(e){return u(e).map((e=>{let{props:{value:n,label:t,attributes:s,default:a}}=e;return{value:n,label:t,attributes:s,default:a}}))}(t);return function(e){const n=(0,d.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const a=(0,i.k6)(),r=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,l._X)(r),(0,s.useCallback)((e=>{if(!r)return;const n=new URLSearchParams(a.location.search);n.set(r,e),a.replace({...a.location,search:n.toString()})}),[r,a])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:a}=e,r=h(e),[i,l]=(0,s.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:s}=e;if(0===s.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:s}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+s.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const a=null!=(n=s.find((e=>e.default)))?n:s[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:n,tabValues:r}))),[d,u]=m({queryString:t,groupId:a}),[f,g]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[a,r]=(0,c.Nk)(t);return[a,(0,s.useCallback)((e=>{t&&r.set(e)}),[t,r])]}({groupId:a}),j=(()=>{const e=null!=d?d:f;return p({value:e,tabValues:r})?e:null})();(0,o.Z)((()=>{j&&l(j)}),[j]);return{selectedValue:i,selectValue:(0,s.useCallback)((e=>{if(!p({value:e,tabValues:r}))throw new Error("Can't select invalid tab value="+e);l(e),u(e),g(e)}),[u,g,r]),tabValues:r}}var g=t(72389),j={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"},b=t(85893);function x(e){let{className:n,block:t,selectedValue:s,selectValue:i,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:d}=(0,r.o5)(),c=e=>{const n=e.currentTarget,t=l.indexOf(n),a=o[t].value;a!==s&&(d(n),i(a))},u=e=>{var n;let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{var s;const n=l.indexOf(e.currentTarget)+1;t=null!=(s=l[n])?s:l[0];break}case"ArrowLeft":{var a;const n=l.indexOf(e.currentTarget)-1;t=null!=(a=l[n])?a:l[l.length-1];break}}null==(n=t)||n.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":t},n),children:o.map((e=>{let{value:n,label:t,attributes:r}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:s===n?0:-1,"aria-selected":s===n,ref:e=>l.push(e),onKeyDown:u,onClick:c,...r,className:(0,a.Z)("tabs__item",j.tabItem,null==r?void 0:r.className,{"tabs__item--active":s===n}),children:null!=t?t:n},n)}))})}function v(e){let{lazy:n,children:t,selectedValue:a}=e;const r=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=r.find((e=>e.props.value===a));return e?(0,s.cloneElement)(e,{className:"margin-top--md"}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:r.map(((e,n)=>(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==a})))})}function y(e){const n=f(e);return(0,b.jsxs)("div",{className:(0,a.Z)("tabs-container",j.tabList),children:[(0,b.jsx)(x,{...e,...n}),(0,b.jsx)(v,{...e,...n})]})}function w(e){const n=(0,g.Z)();return(0,b.jsx)(y,{...e,children:u(e.children)},String(n))}},11151:function(e,n,t){t.d(n,{Z:function(){return o},a:function(){return i}});var s=t(67294);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);