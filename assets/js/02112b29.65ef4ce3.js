"use strict";(self.webpackChunkbento=self.webpackChunkbento||[]).push([[9723],{782:function(e,n,i){i.r(n),i.d(n,{assets:function(){return s},contentTitle:function(){return a},default:function(){return h},frontMatter:function(){return t},metadata:function(){return l},toc:function(){return d}});var o=i(5893),r=i(1151);const t={title:"Bloblang Arithmetic",sidebar_label:"Arithmetic",description:"How arithmetic works within Bloblang"},a=void 0,l={id:"guides/bloblang/arithmetic",title:"Bloblang Arithmetic",description:"How arithmetic works within Bloblang",source:"@site/docs/guides/bloblang/arithmetic.md",sourceDirName:"guides/bloblang",slug:"/guides/bloblang/arithmetic",permalink:"/bento/docs/guides/bloblang/arithmetic",draft:!1,unlisted:!1,editUrl:"https://github.com/warpstreamlabs/bento/edit/main/website/docs/guides/bloblang/arithmetic.md",tags:[],version:"current",frontMatter:{title:"Bloblang Arithmetic",sidebar_label:"Arithmetic",description:"How arithmetic works within Bloblang"},sidebar:"docs",previous:{title:"Methods",permalink:"/bento/docs/guides/bloblang/methods"},next:{title:"Advanced",permalink:"/bento/docs/guides/bloblang/advanced"}},s={},d=[{value:"Mathematical",id:"mathematical",level:2},{value:"Number Degradation",id:"number-degradation",level:3},{value:"Comparison",id:"comparison",level:2},{value:"Equality",id:"equality",level:3},{value:"Numerical",id:"numerical",level:3},{value:"Boolean",id:"boolean",level:3}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",p:"p",...(0,r.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["Bloblang supports a range of comparison operators ",(0,o.jsx)(n.code,{children:"!"}),", ",(0,o.jsx)(n.code,{children:">"}),", ",(0,o.jsx)(n.code,{children:">="}),", ",(0,o.jsx)(n.code,{children:"=="}),", ",(0,o.jsx)(n.code,{children:"<"}),", ",(0,o.jsx)(n.code,{children:"<="}),", ",(0,o.jsx)(n.code,{children:"&&"}),", ",(0,o.jsx)(n.code,{children:"||"})," and mathematical operators ",(0,o.jsx)(n.code,{children:"+"}),", ",(0,o.jsx)(n.code,{children:"-"}),", ",(0,o.jsx)(n.code,{children:"*"}),", ",(0,o.jsx)(n.code,{children:"/"}),", ",(0,o.jsx)(n.code,{children:"%"}),". How these operators behave is dependent on the type of the values they're used with, and therefore it's worth fully understanding these behaviors if you intend to use them heavily in your mappings."]}),"\n",(0,o.jsx)(n.h2,{id:"mathematical",children:"Mathematical"}),"\n",(0,o.jsxs)(n.p,{children:["All mathematical operators (",(0,o.jsx)(n.code,{children:"+"}),", ",(0,o.jsx)(n.code,{children:"-"}),", ",(0,o.jsx)(n.code,{children:"*"}),", ",(0,o.jsx)(n.code,{children:"/"}),", ",(0,o.jsx)(n.code,{children:"%"}),") are valid against number values, and addition (",(0,o.jsx)(n.code,{children:"+"}),") is also supported when both the left and right hand side arguments are strings. If a mathematical operator is used with an argument that is non-numeric (with the aforementioned string exception) then a ",(0,o.jsx)(n.a,{href:"/docs/guides/bloblang/about#error-handling",children:"recoverable mapping error will be thrown"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"number-degradation",children:"Number Degradation"}),"\n",(0,o.jsx)(n.p,{children:"In Bloblang any number resulting from a method, function or arithmetic is either a 64-bit signed integer or a 64-bit floating point value. Numbers from input documents can be any combination of size and be signed or unsigned."}),"\n",(0,o.jsx)(n.p,{children:"When a mathematical operation is performed with two or more integer values Bloblang will create an integer result, with the exception of division. However, if any number within a mathematical operation is a floating point then the result will be a floating point value."}),"\n",(0,o.jsxs)(n.p,{children:["In order to explicitly coerce numbers into integer types you can use the ",(0,o.jsxs)(n.a,{href:"/docs/guides/bloblang/methods#number-manipulation",children:[(0,o.jsx)(n.code,{children:".ceil()"}),", ",(0,o.jsx)(n.code,{children:".floor()"}),", or ",(0,o.jsx)(n.code,{children:".round()"})," methods"]}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"comparison",children:"Comparison"}),"\n",(0,o.jsxs)(n.p,{children:["The not (",(0,o.jsx)(n.code,{children:"!"}),") operator reverses the boolean value of the expression immediately following it, and is valid to place before any query that yields a boolean value. If the following expression yields a non-boolean value then a ",(0,o.jsx)(n.a,{href:"/docs/guides/bloblang/about#error-handling",children:"recoverable mapping error will be thrown"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["If you wish to reverse the boolean result of a complex query then simply place the query within brackets (",(0,o.jsx)(n.code,{children:"!(this.foo > this.bar)"}),")."]}),"\n",(0,o.jsx)(n.h3,{id:"equality",children:"Equality"}),"\n",(0,o.jsxs)(n.p,{children:["The equality operators (",(0,o.jsx)(n.code,{children:"=="})," and ",(0,o.jsx)(n.code,{children:"!="}),") are valid to use against any value type. In order for arguments to be considered equal they must match in both their basic type (",(0,o.jsx)(n.code,{children:"string"}),", ",(0,o.jsx)(n.code,{children:"number"}),", ",(0,o.jsx)(n.code,{children:"null"}),", ",(0,o.jsx)(n.code,{children:"bool"}),", etc) as well as their value. If you wish to compare mismatched value types then use ",(0,o.jsx)(n.a,{href:"/docs/guides/bloblang/methods#type-coercion",children:"coercion methods"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Number arguments are considered equal if their value is the same when represented the same way, which means their underlying representations (integer, float, etc) do not need to match in order for them to be considered equal."}),"\n",(0,o.jsx)(n.h3,{id:"numerical",children:"Numerical"}),"\n",(0,o.jsxs)(n.p,{children:["Numerical comparisons (",(0,o.jsx)(n.code,{children:">"}),", ",(0,o.jsx)(n.code,{children:">="}),", ",(0,o.jsx)(n.code,{children:"<"}),", ",(0,o.jsx)(n.code,{children:"<="}),") are valid to use against number values only. If a non-number value is used as an argument then a ",(0,o.jsx)(n.a,{href:"/docs/guides/bloblang/about#error-handling",children:"recoverable mapping error will be thrown"}),"."]}),"\n",(0,o.jsx)(n.h3,{id:"boolean",children:"Boolean"}),"\n",(0,o.jsxs)(n.p,{children:["Boolean comparison operators (",(0,o.jsx)(n.code,{children:"||"}),", ",(0,o.jsx)(n.code,{children:"&&"}),") are valid to use against boolean values only (",(0,o.jsx)(n.code,{children:"true"})," or ",(0,o.jsx)(n.code,{children:"false"}),"). If a non-boolean value is used as an argument then a ",(0,o.jsx)(n.a,{href:"/docs/guides/bloblang/about#error-handling",children:"recoverable mapping error will be thrown"}),"."]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},1151:function(e,n,i){i.d(n,{Z:function(){return l},a:function(){return a}});var o=i(7294);const r={},t=o.createContext(r);function a(e){const n=o.useContext(t);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(t.Provider,{value:n},e.children)}}}]);