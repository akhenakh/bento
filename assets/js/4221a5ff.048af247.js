"use strict";(self.webpackChunkbento=self.webpackChunkbento||[]).push([[7036],{68565:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return i},default:function(){return h},frontMatter:function(){return s},metadata:function(){return r},toc:function(){return c}});var o=t(85893),a=t(11151);const s={title:"Bloblang",sidebar_label:"About",description:"The Bento native mapping language"},i=void 0,r={id:"guides/bloblang/about",title:"Bloblang",description:"The Bento native mapping language",source:"@site/docs/guides/bloblang/about.md",sourceDirName:"guides/bloblang",slug:"/guides/bloblang/about",permalink:"/docs/guides/bloblang/about",draft:!1,unlisted:!1,editUrl:"https://github.com/warpstreamlabs/bento/edit/main/website/docs/guides/bloblang/about.md",tags:[],version:"current",frontMatter:{title:"Bloblang",sidebar_label:"About",description:"The Bento native mapping language"},sidebar:"docs",previous:{title:"Getting Started",permalink:"/docs/guides/getting_started"},next:{title:"Walkthrough",permalink:"/docs/guides/bloblang/walkthrough"}},l={},c=[{value:"Assignment",id:"assignment",level:2},{value:"Special Characters in Paths",id:"special-characters-in-paths",level:3},{value:"Non-structured Data",id:"non-structured-data",level:3},{value:"Deleting",id:"deleting",level:3},{value:"Variables",id:"variables",level:3},{value:"Metadata",id:"metadata",level:3},{value:"Coalesce",id:"coalesce",level:2},{value:"Literals",id:"literals",level:2},{value:"Comments",id:"comments",level:2},{value:"Boolean Logic and Arithmetic",id:"boolean-logic-and-arithmetic",level:2},{value:"Conditional Mapping",id:"conditional-mapping",level:2},{value:"Pattern Matching",id:"pattern-matching",level:2},{value:"Functions",id:"functions",level:2},{value:"Methods",id:"methods",level:2},{value:"Maps",id:"maps",level:2},{value:"Import Maps",id:"import-maps",level:2},{value:"Filtering",id:"filtering",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Unit Testing",id:"unit-testing",level:2},{value:"Trouble Shooting",id:"trouble-shooting",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(n.p,{children:["Bloblang, or blobl for short, is a language designed for mapping data of a wide variety of forms. It's a safe, fast, and powerful way to perform document mapping within Bento. It also has a ",(0,o.jsx)(n.a,{href:"https://pkg.go.dev/github.com/warpstreamlabs/bento/v4/public/bloblang",children:"Go API for writing your own functions and methods"})," as plugins."]}),"\n",(0,o.jsxs)(n.p,{children:["Bloblang is available as a ",(0,o.jsx)(n.a,{href:"/docs/components/processors/mapping",children:"processor"})," and it's also possible to use blobl queries in ",(0,o.jsx)(n.a,{href:"/docs/configuration/interpolation#bloblang-queries",children:"function interpolations"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["You can also execute Bloblang mappings on the command-line with the ",(0,o.jsx)(n.code,{children:"blobl"})," subcommand:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"$ cat data.jsonl | bento blobl 'foo.(bar | baz).buz'\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This document outlines the core features of the Bloblang language, but if you're totally new to Bloblang then it's worth following ",(0,o.jsx)(n.a,{href:"/docs/guides/bloblang/walkthrough",children:"the walkthrough first"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"assignment",children:"Assignment"}),"\n",(0,o.jsx)(n.p,{children:"A Bloblang mapping expresses how to create a new document by extracting data from an existing input document. Assignments consist of a dot separated path segments on the left-hand side describing a field to be created within the new document, and a right-hand side query describing what the content of the new field should be."}),"\n",(0,o.jsxs)(n.p,{children:["The keyword ",(0,o.jsx)(n.code,{children:"root"})," on the left-hand side refers to the root of the new document, the keyword ",(0,o.jsx)(n.code,{children:"this"})," on the right-hand side refers to the current context of the query, which is the read-only input document when querying from the root of a mapping:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'root.id = this.thing.id\nroot.type = "yo"\n\n# Both `root` and `this` are optional, and will be inferred in their absence.\ncontent = thing.doc.message\n\n# In:  {"thing":{"id":"wat1","doc":{"title":"wut","message":"hello world"}}}\n# Out: {"content":"hello world","id":"wat1","type":"yo"}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Since the document being created starts off empty it is sometimes useful to begin a mapping by copying the entire contents of the input document, which can be expressed by assigning ",(0,o.jsx)(n.code,{children:"this"})," to ",(0,o.jsx)(n.code,{children:"root"}),"."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'root = this\nroot.foo = "added value"\n\n# In:  {"id":"wat1","message":"hello world"}\n# Out: {"id":"wat1","message":"hello world","foo":"added value"}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["If the new document ",(0,o.jsx)(n.code,{children:"root"})," is never assigned to or otherwise mutated then the original document remains unchanged."]}),"\n",(0,o.jsx)(n.h3,{id:"special-characters-in-paths",children:"Special Characters in Paths"}),"\n",(0,o.jsx)(n.p,{children:"Quotes can be used to describe sections of a field path that contain whitespace, dots or other special characters:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'# Use quotes around a path segment in order to include whitespace or dots within\n# the path\nroot."foo.bar".baz = this."buz bev".fub\n\n# In:  {"buz bev":{"fub":"hello world"}}\n# Out: {"foo.bar":{"baz":"hello world"}}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"non-structured-data",children:"Non-structured Data"}),"\n",(0,o.jsxs)(n.p,{children:["Bloblang is able to map data that is unstructured, whether it's a log line or a binary blob, by referencing it with the ",(0,o.jsxs)(n.a,{href:"/docs/guides/bloblang/functions#content",children:[(0,o.jsx)(n.code,{children:"content"})," function"]}),", which returns the raw bytes of the input document:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'# Parse a base64 encoded JSON document\nroot = content().decode("base64").parse_json()\n\n# In:  eyJmb28iOiJiYXIifQ==\n# Out: {"foo":"bar"}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["And your newly mapped document can also be unstructured, simply assign a value type to the ",(0,o.jsx)(n.code,{children:"root"})," of your document:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'root = this.foo\n\n# In:  {"foo":"hello world"}\n# Out: hello world\n'})}),"\n",(0,o.jsx)(n.p,{children:"And the resulting message payload will be the raw value you've assigned."}),"\n",(0,o.jsx)(n.h3,{id:"deleting",children:"Deleting"}),"\n",(0,o.jsxs)(n.p,{children:["It's possible to selectively delete fields from an object by assigning the function ",(0,o.jsx)(n.code,{children:"deleted()"})," to the field path:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'root = this\nroot.bar = deleted()\n\n# In:  {"id":"wat1","message":"hello world","bar":"remove me"}\n# Out: {"id":"wat1","message":"hello world"}\n'})}),"\n",(0,o.jsx)(n.h3,{id:"variables",children:"Variables"}),"\n",(0,o.jsxs)(n.p,{children:["Another type of assignment is a ",(0,o.jsx)(n.code,{children:"let"})," statement, which creates a variable that can be referenced elsewhere within a mapping. Variables are discarded at the end of the mapping and are mostly useful for query reuse. Variables are referenced within queries with ",(0,o.jsx)(n.code,{children:"$"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'# Set a temporary variable\nlet foo = "yo"\n\nroot.new_doc.type = $foo\n'})}),"\n",(0,o.jsx)(n.h3,{id:"metadata",children:"Metadata"}),"\n",(0,o.jsxs)(n.p,{children:["Bento messages contain metadata that is separate from the main payload, in Bloblang you can modify the metadata of the resulting message with the ",(0,o.jsx)(n.code,{children:"meta"})," assignment keyword. Metadata values of the resulting message are referenced within queries with the ",(0,o.jsx)(n.code,{children:"@"})," operator or the ",(0,o.jsxs)(n.a,{href:"/docs/guides/bloblang/functions#metadata",children:[(0,o.jsx)(n.code,{children:"metadata()"})," function"]}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'# Reference a metadata value\nroot.new_doc.bar = @kafka_topic # Or `@.kafka_topic` or `metadata("kafka_topic")`\n\n# Delete all metadata\nmeta = deleted()\n\n# Set metadata values\nmeta bar = "hello world"\nmeta baz = {\n  "something": "structured"\n}\n\n# Get an object of key/values for all metadata\nroot.meta_obj = @ # Or `metadata()`\n'})}),"\n",(0,o.jsx)(n.h2,{id:"coalesce",children:"Coalesce"}),"\n",(0,o.jsxs)(n.p,{children:["The pipe operator (",(0,o.jsx)(n.code,{children:"|"}),") used within brackets allows you to coalesce multiple candidates for a path segment. The first field that exists and has a non-null value will be selected:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'root.new_doc.type = this.thing.(article | comment | this).type\n\n# In:  {"thing":{"article":{"type":"foo"}}}\n# Out: {"new_doc":{"type":"foo"}}\n\n# In:  {"thing":{"comment":{"type":"bar"}}}\n# Out: {"new_doc":{"type":"bar"}}\n\n# In:  {"thing":{"type":"baz"}}\n# Out: {"new_doc":{"type":"baz"}}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Opening brackets on a field begins a query where the context of ",(0,o.jsx)(n.code,{children:"this"})," changes to value of the path it is opened upon, therefore in the above example ",(0,o.jsx)(n.code,{children:"this"})," within the brackets refers to the contents of ",(0,o.jsx)(n.code,{children:"this.thing"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"literals",children:"Literals"}),"\n",(0,o.jsx)(n.p,{children:"Bloblang supports number, boolean, string, null, array and object literals:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'root = [\n  7, false, "string", null, {\n    "first": 11,\n    "second": {"foo":"bar"},\n    "third": """multiple\nlines on this\nstring"""\n  }\n]\n\n# In:  {}\n# Out: [7,false,"string",null,{"first":11,"second":{"foo":"bar"},"third":"multiple\\nlines on this\\nstring"}]\n'})}),"\n",(0,o.jsx)(n.p,{children:"The values within literal arrays and objects can be dynamic query expressions, as well as the keys of object literals."}),"\n",(0,o.jsx)(n.h2,{id:"comments",children:"Comments"}),"\n",(0,o.jsxs)(n.p,{children:["You might've already spotted, comments are started with a hash (",(0,o.jsx)(n.code,{children:"#"}),") and end with a line break:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:"root = this.some.value # And now this is a comment\n"})}),"\n",(0,o.jsx)(n.h2,{id:"boolean-logic-and-arithmetic",children:"Boolean Logic and Arithmetic"}),"\n",(0,o.jsxs)(n.p,{children:["Bloblang supports a range of boolean operators ",(0,o.jsx)(n.code,{children:"!"}),", ",(0,o.jsx)(n.code,{children:">"}),", ",(0,o.jsx)(n.code,{children:">="}),", ",(0,o.jsx)(n.code,{children:"=="}),", ",(0,o.jsx)(n.code,{children:"<"}),", ",(0,o.jsx)(n.code,{children:"<="}),", ",(0,o.jsx)(n.code,{children:"&&"}),", ",(0,o.jsx)(n.code,{children:"||"})," and mathematical operators ",(0,o.jsx)(n.code,{children:"+"}),", ",(0,o.jsx)(n.code,{children:"-"}),", ",(0,o.jsx)(n.code,{children:"*"}),", ",(0,o.jsx)(n.code,{children:"/"}),", ",(0,o.jsx)(n.code,{children:"%"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'root.is_big = this.number > 100\nroot.multiplied = this.number * 7\n\n# In:  {"number":50}\n# Out: {"is_big":false,"multiplied":350}\n\n# In:  {"number":150}\n# Out: {"is_big":true,"multiplied":1050}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["For more information about these operators and how they work check out ",(0,o.jsx)(n.a,{href:"/docs/guides/bloblang/arithmetic",children:"the arithmetic page"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"conditional-mapping",children:"Conditional Mapping"}),"\n",(0,o.jsxs)(n.p,{children:["Use ",(0,o.jsx)(n.code,{children:"if"})," as either a statement or an expression in order to perform maps conditionally:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'root = this\n\nroot.sorted_foo = if this.foo.type() == "array" { this.foo.sort() }\n\nif this.foo.type() == "string" {\n  root.upper_foo = this.foo.uppercase()\n  root.lower_foo = this.foo.lowercase()\n}\n\n# In:  {"foo":"FooBar"}\n# Out: {"foo":"FooBar","lower_foo":"foobar","upper_foo":"FOOBAR"}\n\n# In:  {"foo":["foo","bar"]}\n# Out: {"foo":["foo","bar"],"sorted_foo":["bar","foo"]}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["And add as many ",(0,o.jsx)(n.code,{children:"else if"})," queries as you like, followed by an optional final fallback ",(0,o.jsx)(n.code,{children:"else"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'root.sound = if this.type == "cat" {\n  this.cat.meow\n} else if this.type == "dog" {\n  this.dog.woof.uppercase()\n} else {\n  "sweet sweet silence"\n}\n\n# In:  {"type":"cat","cat":{"meow":"meeeeooooow!"}}\n# Out: {"sound":"meeeeooooow!"}\n\n# In:  {"type":"dog","dog":{"woof":"guurrrr woof woof!"}}\n# Out: {"sound":"GUURRRR WOOF WOOF!"}\n\n# In:  {"type":"caterpillar","caterpillar":{"name":"oleg"}}\n# Out: {"sound":"sweet sweet silence"}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"pattern-matching",children:"Pattern Matching"}),"\n",(0,o.jsxs)(n.p,{children:["A ",(0,o.jsx)(n.code,{children:"match"})," expression allows you to perform conditional mappings on a value, each case should be either a boolean expression, a literal value to compare against the target value, or an underscore (",(0,o.jsx)(n.code,{children:"_"}),") which captures values that have not matched a prior case:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'root.new_doc = match this.doc {\n  this.type == "article" => this.article\n  this.type == "comment" => this.comment\n  _ => this\n}\n\n# In:  {"doc":{"type":"article","article":{"id":"foo","content":"qux"}}}\n# Out: {"new_doc":{"id":"foo","content":"qux"}}\n\n# In:  {"doc":{"type":"comment","comment":{"id":"bar","content":"quz"}}}\n# Out: {"new_doc":{"id":"bar","content":"quz"}}\n\n# In:  {"doc":{"type":"neither","content":"some other stuff unchanged"}}\n# Out: {"new_doc":{"type":"neither","content":"some other stuff unchanged"}}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Within a match block the context of ",(0,o.jsx)(n.code,{children:"this"})," changes to the pattern matched expression, therefore ",(0,o.jsx)(n.code,{children:"this"})," within the match expression above refers to ",(0,o.jsx)(n.code,{children:"this.doc"}),"."]}),"\n",(0,o.jsx)(n.p,{children:"Match cases can specify a literal value for simple comparison:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'root = this\nroot.type = match this.type { "doc" => "document", "art" => "article", _ => this }\n\n# In:  {"type":"doc","foo":"bar"}\n# Out: {"type":"document","foo":"bar"}\n'})}),"\n",(0,o.jsx)(n.p,{children:"The match expression can also be left unset which means the context remains unchanged, and the catch-all case can also be omitted:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'root.new_doc = match {\n  this.doc.type == "article" => this.doc.article\n  this.doc.type == "comment" => this.doc.comment\n}\n\n# In:  {"doc":{"type":"neither","content":"some other stuff unchanged"}}\n# Out: {"doc":{"type":"neither","content":"some other stuff unchanged"}}\n'})}),"\n",(0,o.jsx)(n.p,{children:"If no case matches then the mapping is skipped entirely, hence we would end up with the original document in this case."}),"\n",(0,o.jsx)(n.h2,{id:"functions",children:"Functions"}),"\n",(0,o.jsx)(n.p,{children:"Functions can be placed anywhere and allow you to extract information from your environment, generate values, or access data from the underlying message being mapped:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:"root.doc.id = uuid_v4()\nroot.doc.received_at = now()\nroot.doc.host = hostname()\n"})}),"\n",(0,o.jsx)(n.p,{children:"Functions support both named and nameless style arguments:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:"root.values_one = range(start: 0, stop: this.max, step: 2)\nroot.values_two = range(0, this.max, 2)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["You can find a full list of functions and their parameters in ",(0,o.jsx)(n.a,{href:"/docs/guides/bloblang/functions",children:"the functions page"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,o.jsx)(n.p,{children:"Methods are similar to functions but enact upon a target value, these provide most of the power in Bloblang as they allow you to augment query values and can be added to any expression (including other methods):"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'root.doc.id = this.thing.id.string().catch(uuid_v4())\nroot.doc.reduced_nums = this.thing.nums.map_each(num -> if num < 10 {\n  deleted()\n} else {\n  num - 10\n})\nroot.has_good_taste = ["pikachu","mewtwo","magmar"].contains(this.user.fav_pokemon)\n'})}),"\n",(0,o.jsx)(n.p,{children:"Methods also support both named and nameless style arguments:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'root.foo_one = this.(bar | baz).trim().replace_all(old: "dog", new: "cat")\nroot.foo_two = this.(bar | baz).trim().replace_all("dog", "cat")\n'})}),"\n",(0,o.jsxs)(n.p,{children:["You can find a full list of methods and their parameters in ",(0,o.jsx)(n.a,{href:"/docs/guides/bloblang/methods",children:"the methods page"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"maps",children:"Maps"}),"\n",(0,o.jsxs)(n.p,{children:["Defining named maps allows you to reuse common mappings on values with the ",(0,o.jsxs)(n.a,{href:"/docs/guides/bloblang/methods#apply",children:[(0,o.jsx)(n.code,{children:"apply"})," method"]}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'map things {\n  root.first  = this.thing_one\n  root.second = this.thing_two\n}\n\nroot.foo = this.value_one.apply("things")\nroot.bar = this.value_two.apply("things")\n\n# In:  {"value_one":{"thing_one":"hey","thing_two":"yo"},"value_two":{"thing_one":"sup","thing_two":"waddup"}}\n# Out: {"foo":{"first":"hey","second":"yo"},"bar":{"first":"sup","second":"waddup"}}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Within a map the keyword ",(0,o.jsx)(n.code,{children:"root"})," refers to a newly created document that will replace the target of the map, and ",(0,o.jsx)(n.code,{children:"this"})," refers to the original value of the target. The argument of ",(0,o.jsx)(n.code,{children:"apply"})," is a string, which allows you to dynamically resolve the mapping to apply."]}),"\n",(0,o.jsx)(n.h2,{id:"import-maps",children:"Import Maps"}),"\n",(0,o.jsxs)(n.p,{children:["It's possible to import maps defined in a file with an ",(0,o.jsx)(n.code,{children:"import"})," statement:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'import "./common_maps.blobl"\n\nroot.foo = this.value_one.apply("things")\nroot.bar = this.value_two.apply("things")\n'})}),"\n",(0,o.jsx)(n.p,{children:"Imports from a Bloblang mapping within a Bento config are relative to the process running the config. Imports from an imported file are relative to the file that is importing it."}),"\n",(0,o.jsx)(n.h2,{id:"filtering",children:"Filtering"}),"\n",(0,o.jsxs)(n.p,{children:["By assigning the root of a mapped document to the ",(0,o.jsx)(n.code,{children:"deleted()"})," function you can delete a message entirely:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:"# Filter all messages that have fewer than 10 URLs.\nroot = if this.doc.urls.length() < 10 { deleted() }\n"})}),"\n",(0,o.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,o.jsxs)(n.p,{children:["Functions and methods can fail under certain circumstances, such as when they receive types they aren't able to act upon. These failures, when not caught, will cause the entire mapping to fail. However, the ",(0,o.jsxs)(n.a,{href:"/docs/guides/bloblang/methods#catch",children:["method ",(0,o.jsx)(n.code,{children:"catch"})]})," can be used in order to return a value when a failure occurs instead:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'# Map an empty array to `foo` if the field `bar` is not a string.\nroot.foo = this.bar.split(",").catch([])\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Since ",(0,o.jsx)(n.code,{children:"catch"})," is a method it can also be attached to bracketed map expressions:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'# Map `false` if any of the operations in this boolean query fail.\nroot.thing = ( this.foo > this.bar && this.baz.contains("wut") ).catch(false)\n'})}),"\n",(0,o.jsxs)(n.p,{children:["And one of the more powerful features of Bloblang is that a single ",(0,o.jsx)(n.code,{children:"catch"})," method at the end of a chain of methods can recover errors from any method in the chain:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'# Catch errors caused by:\n# - foo not existing\n# - foo not being a string\n# - an element from split foo not being a valid JSON string\nroot.things = this.foo.split(",").map_each( ele -> ele.parse_json() ).catch([])\n\n# Specifically catch a JSON parse error\nroot.things = this.foo.split(",").map_each( ele -> ele.parse_json().catch({}) )\n'})}),"\n",(0,o.jsxs)(n.p,{children:["However, the ",(0,o.jsx)(n.code,{children:"catch"})," method only acts on errors, sometimes it's also useful to set a fall back value when a query returns ",(0,o.jsx)(n.code,{children:"null"})," in which case the ",(0,o.jsxs)(n.a,{href:"/docs/guides/bloblang/methods#or",children:["method ",(0,o.jsx)(n.code,{children:"or"})]})," can be used the same way:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-coffee",children:'# Map "default" if either the element index 5 does not exist, or the underlying\n# element is `null`.\nroot.foo = this.bar.index(5).or("default")\n'})}),"\n",(0,o.jsx)(n.h2,{id:"unit-testing",children:"Unit Testing"}),"\n",(0,o.jsxs)(n.p,{children:["It's possible to execute unit tests for your Bloblang mappings using the standard Bento unit test capabilities outlined ",(0,o.jsx)(n.a,{href:"/docs/configuration/unit_testing",children:"in this document"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"trouble-shooting",children:"Trouble Shooting"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:["I'm seeing ",(0,o.jsx)(n.code,{children:"unable to reference message as structured (with 'this')"})," when I try to run mappings with ",(0,o.jsx)(n.code,{children:"bento blobl"}),"."]}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["That particular error message means the mapping is failing to parse what's being fed in as a JSON document. Make sure that the data you are feeding in is valid JSON, and also that the documents ",(0,o.jsx)(n.em,{children:"do not"})," contain line breaks as ",(0,o.jsx)(n.code,{children:"bento blobl"})," will parse each line individually."]}),"\n",(0,o.jsxs)(n.p,{children:["Why? That's a good question. Bloblang supports non-JSON formats too, so it can't delimit documents with a streaming JSON parser like tools such as ",(0,o.jsx)(n.code,{children:"jq"}),", so instead it uses line breaks to determine the boundaries of each message."]})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},11151:function(e,n,t){t.d(n,{Z:function(){return r},a:function(){return i}});var o=t(67294);const a={},s=o.createContext(a);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);