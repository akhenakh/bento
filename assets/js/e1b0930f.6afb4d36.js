"use strict";(self.webpackChunkbento=self.webpackChunkbento||[]).push([[1854],{64595:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return i},default:function(){return p},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return d}});var r=t(85893),s=t(11151),a=t(74866),o=t(85162);const l={title:"branch",slug:"branch",type:"processor",status:"stable",categories:["Composition"],name:"branch"},i=void 0,c={id:"components/processors/branch",title:"branch",description:"\x3c!--",source:"@site/docs/components/processors/branch.md",sourceDirName:"components/processors",slug:"/components/processors/branch",permalink:"/bento/docs/components/processors/branch",draft:!1,unlisted:!1,editUrl:"https://github.com/warpstreamlabs/bento/edit/main/website/docs/components/processors/branch.md",tags:[],version:"current",frontMatter:{title:"branch",slug:"branch",type:"processor",status:"stable",categories:["Composition"],name:"branch"},sidebar:"docs",previous:{title:"bounds_check",permalink:"/bento/docs/components/processors/bounds_check"},next:{title:"cache",permalink:"/bento/docs/components/processors/cache"}},u={},d=[{value:"Metadata",id:"metadata",level:3},{value:"Error Handling",id:"error-handling",level:3},{value:"Conditional Branching",id:"conditional-branching",level:3},{value:"Fields",id:"fields",level:2},{value:"<code>request_map</code>",id:"request_map",level:3},{value:"<code>processors</code>",id:"processors",level:3},{value:"<code>result_map</code>",id:"result_map",level:3},{value:"Examples",id:"examples",level:2}];function h(e){const n={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"branch"})," processor allows you to create a new request message via a ",(0,r.jsx)(n.a,{href:"/docs/guides/bloblang/about",children:"Bloblang mapping"}),", execute a list of processors on the request messages, and, finally, map the result back into the source message using another mapping."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yml",children:'# Config fields, showing default values\nlabel: ""\nbranch:\n  request_map: ""\n  processors: [] # No default (required)\n  result_map: ""\n'})}),"\n",(0,r.jsx)(n.p,{children:"This is useful for preserving the original message contents when using processors that would otherwise replace the entire contents."}),"\n",(0,r.jsx)(n.h3,{id:"metadata",children:"Metadata"}),"\n",(0,r.jsxs)(n.p,{children:["Metadata fields that are added to messages during branch processing will not be automatically copied into the resulting message. In order to do this you should explicitly declare in your ",(0,r.jsx)(n.code,{children:"result_map"})," either a wholesale copy with ",(0,r.jsx)(n.code,{children:"meta = metadata()"}),", or selective copies with ",(0,r.jsx)(n.code,{children:'meta foo = metadata("bar")'})," and so on. It is also possible to reference the metadata of the origin message in the ",(0,r.jsx)(n.code,{children:"result_map"})," using the ",(0,r.jsxs)(n.a,{href:"/docs/guides/bloblang/about#metadata",children:[(0,r.jsx)(n.code,{children:"@"})," operator"]}),"."]}),"\n",(0,r.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsxs)(n.p,{children:["If the ",(0,r.jsx)(n.code,{children:"request_map"})," fails the child processors will not be executed. If the child processors themselves result in an (uncaught) error then the ",(0,r.jsx)(n.code,{children:"result_map"})," will not be executed. If the ",(0,r.jsx)(n.code,{children:"result_map"})," fails the message will remain unchanged. Under any of these conditions standard ",(0,r.jsx)(n.a,{href:"/docs/configuration/error_handling",children:"error handling methods"})," can be used in order to filter, DLQ or recover the failed messages."]}),"\n",(0,r.jsx)(n.h3,{id:"conditional-branching",children:"Conditional Branching"}),"\n",(0,r.jsxs)(n.p,{children:["If the root of your request map is set to ",(0,r.jsx)(n.code,{children:"deleted()"})," then the branch processors are skipped for the given message, this allows you to conditionally branch messages."]}),"\n",(0,r.jsx)(n.h2,{id:"fields",children:"Fields"}),"\n",(0,r.jsx)(n.h3,{id:"request_map",children:(0,r.jsx)(n.code,{children:"request_map"})}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.a,{href:"/docs/guides/bloblang/about",children:"Bloblang mapping"})," that describes how to create a request payload suitable for the child processors of this branch. If left empty then the branch will begin with an exact copy of the origin message (including metadata)."]}),"\n",(0,r.jsxs)(n.p,{children:["Type: ",(0,r.jsx)(n.code,{children:"string"}),(0,r.jsx)(n.br,{}),"\n","Default: ",(0,r.jsx)(n.code,{children:'""'})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yml",children:'# Examples\n\nrequest_map: |-\n  root = {\n  \t"id": this.doc.id,\n  \t"content": this.doc.body.text\n  }\n\nrequest_map: |-\n  root = if this.type == "foo" {\n  \tthis.foo.request\n  } else {\n  \tdeleted()\n  }\n'})}),"\n",(0,r.jsx)(n.h3,{id:"processors",children:(0,r.jsx)(n.code,{children:"processors"})}),"\n",(0,r.jsx)(n.p,{children:"A list of processors to apply to mapped requests. When processing message batches the resulting batch must match the size and ordering of the input batch, therefore filtering, grouping should not be performed within these processors."}),"\n",(0,r.jsxs)(n.p,{children:["Type: ",(0,r.jsx)(n.code,{children:"array"})]}),"\n",(0,r.jsx)(n.h3,{id:"result_map",children:(0,r.jsx)(n.code,{children:"result_map"})}),"\n",(0,r.jsxs)(n.p,{children:["A ",(0,r.jsx)(n.a,{href:"/docs/guides/bloblang/about",children:"Bloblang mapping"})," that describes how the resulting messages from branched processing should be mapped back into the original payload. If left empty the origin message will remain unchanged (including metadata)."]}),"\n",(0,r.jsxs)(n.p,{children:["Type: ",(0,r.jsx)(n.code,{children:"string"}),(0,r.jsx)(n.br,{}),"\n","Default: ",(0,r.jsx)(n.code,{children:'""'})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yml",children:'# Examples\n\nresult_map: |-\n  meta foo_code = metadata("code")\n  root.foo_result = this\n\nresult_map: |-\n  meta = metadata()\n  root.bar.body = this.body\n  root.bar.id = this.user.id\n\nresult_map: root.raw_result = content().string()\n\nresult_map: |-\n  root.enrichments.foo = if metadata("request_failed") != null {\n    throw(metadata("request_failed"))\n  } else {\n    this\n  }\n\nresult_map: |-\n  # Retain only the updated metadata fields which were present in the origin message\n  meta = metadata().filter(v -> @.get(v.key) != null)\n'})}),"\n",(0,r.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsxs)(a.Z,{defaultValue:"HTTP Request",values:[{label:"HTTP Request",value:"HTTP Request"},{label:"Non Structured Results",value:"Non Structured Results"},{label:"Lambda Function",value:"Lambda Function"},{label:"Conditional Caching",value:"Conditional Caching"}],children:[(0,r.jsxs)(o.Z,{value:"HTTP Request",children:[(0,r.jsxs)(n.p,{children:["This example strips the request message into an empty body, grabs an HTTP payload, and places the result back into the original message at the path ",(0,r.jsx)(n.code,{children:"image.pull_count"}),":"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'pipeline:\n  processors:\n    - branch:\n        request_map: \'root = ""\'\n        processors:\n          - http:\n              url: https://hub.docker.com/v2/repositories/jeffail/benthos\n              verb: GET\n              headers:\n                Content-Type: application/json\n        result_map: root.image.pull_count = this.pull_count\n\n# Example input:  {"id":"foo","some":"pre-existing data"}\n# Example output: {"id":"foo","some":"pre-existing data","image":{"pull_count":1234}}\n'})})]}),(0,r.jsxs)(o.Z,{value:"Non Structured Results",children:[(0,r.jsx)(n.p,{children:"When the result of your branch processors is unstructured and you wish to simply set a resulting field to the raw output use the content function to obtain the raw bytes of the resulting message and then coerce it into your value type of choice:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'pipeline:\n  processors:\n    - branch:\n        request_map: \'root = this.document.id\'\n        processors:\n          - cache:\n              resource: descriptions_cache\n              key: ${! content() }\n              operator: get\n        result_map: root.document.description = content().string()\n\n# Example input:  {"document":{"id":"foo","content":"hello world"}}\n# Example output: {"document":{"id":"foo","content":"hello world","description":"this is a cool doc"}}\n'})})]}),(0,r.jsxs)(o.Z,{value:"Lambda Function",children:[(0,r.jsx)(n.p,{children:"This example maps a new payload for triggering a lambda function with an ID and username from the original message, and the result of the lambda is discarded, meaning the original message is unchanged."}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'pipeline:\n  processors:\n    - branch:\n        request_map: \'{"id":this.doc.id,"username":this.user.name}\'\n        processors:\n          - aws_lambda:\n              function: trigger_user_update\n\n# Example input: {"doc":{"id":"foo","body":"hello world"},"user":{"name":"fooey"}}\n# Output matches the input, which is unchanged\n'})})]}),(0,r.jsxs)(o.Z,{value:"Conditional Caching",children:[(0,r.jsx)(n.p,{children:"This example caches a document by a message ID only when the type of the document is a foo:"}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'pipeline:\n  processors:\n    - branch:\n        request_map: |\n          meta id = this.id\n          root = if this.type == "foo" {\n            this.document\n          } else {\n            deleted()\n          }\n        processors:\n          - cache:\n              resource: TODO\n              operator: set\n              key: ${! @id }\n              value: ${! content() }\n'})})]})]})]})}function p(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},85162:function(e,n,t){t.d(n,{Z:function(){return o}});t(67294);var r=t(86010),s={tabItem:"tabItem_Ymn6"},a=t(85893);function o(e){let{children:n,hidden:t,className:o}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,r.Z)(s.tabItem,o),hidden:t,children:n})}},74866:function(e,n,t){t.d(n,{Z:function(){return w}});var r=t(67294),s=t(86010),a=t(12466),o=t(16550),l=t(20469),i=t(91980),c=t(67392),u=t(50012);function d(e){var n,t;return null!=(n=null==(t=r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}function h(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=null!=n?n:function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:s}}=e;return{value:n,label:t,attributes:r,default:s}}))}(t);return function(e){const n=(0,c.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const s=(0,o.k6)(),a=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,i._X)(a),(0,r.useCallback)((e=>{if(!a)return;const n=new URLSearchParams(s.location.search);n.set(a,e),s.replace({...s.location,search:n.toString()})}),[a,s])]}function b(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,a=h(e),[o,i]=(0,r.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:r}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+r.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const s=null!=(n=r.find((e=>e.default)))?n:r[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:a}))),[c,d]=m({queryString:t,groupId:s}),[b,f]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[s,a]=(0,u.Nk)(t);return[s,(0,r.useCallback)((e=>{t&&a.set(e)}),[t,a])]}({groupId:s}),g=(()=>{const e=null!=c?c:b;return p({value:e,tabValues:a})?e:null})();(0,l.Z)((()=>{g&&i(g)}),[g]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:a}))throw new Error("Can't select invalid tab value="+e);i(e),d(e),f(e)}),[d,f,a]),tabValues:a}}var f=t(72389),g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"},x=t(85893);function v(e){let{className:n,block:t,selectedValue:r,selectValue:o,tabValues:l}=e;const i=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.o5)(),u=e=>{const n=e.currentTarget,t=i.indexOf(n),s=l[t].value;s!==r&&(c(n),o(s))},d=e=>{var n;let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{var r;const n=i.indexOf(e.currentTarget)+1;t=null!=(r=i[n])?r:i[0];break}case"ArrowLeft":{var s;const n=i.indexOf(e.currentTarget)-1;t=null!=(s=i[n])?s:i[i.length-1];break}}null==(n=t)||n.focus()};return(0,x.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":t},n),children:l.map((e=>{let{value:n,label:t,attributes:a}=e;return(0,x.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>i.push(e),onKeyDown:d,onClick:u,...a,className:(0,s.Z)("tabs__item",g.tabItem,null==a?void 0:a.className,{"tabs__item--active":r===n}),children:null!=t?t:n},n)}))})}function j(e){let{lazy:n,children:t,selectedValue:s}=e;const a=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=a.find((e=>e.props.value===s));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return(0,x.jsx)("div",{className:"margin-top--md",children:a.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function y(e){const n=b(e);return(0,x.jsxs)("div",{className:(0,s.Z)("tabs-container",g.tabList),children:[(0,x.jsx)(v,{...e,...n}),(0,x.jsx)(j,{...e,...n})]})}function w(e){const n=(0,f.Z)();return(0,x.jsx)(y,{...e,children:d(e.children)},String(n))}},11151:function(e,n,t){t.d(n,{Z:function(){return l},a:function(){return o}});var r=t(67294);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);