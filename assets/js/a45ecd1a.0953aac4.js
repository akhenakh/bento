"use strict";(self.webpackChunkbento=self.webpackChunkbento||[]).push([[1180],{89412:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return r},default:function(){return l},frontMatter:function(){return s},metadata:function(){return a},toc:function(){return u}});var i=t(85893),o=t(11151);const s={title:"Processing Pipelines"},r=void 0,a={id:"configuration/processing_pipelines",title:"Processing Pipelines",description:"Within a Bento configuration, in between input and output, is a pipeline section. This section describes an array of processors that are to be applied to all messages, and are not bound to any particular input or output.",source:"@site/docs/configuration/processing_pipelines.md",sourceDirName:"configuration",slug:"/configuration/processing_pipelines",permalink:"/bento/docs/configuration/processing_pipelines",draft:!1,unlisted:!1,editUrl:"https://github.com/warpstreamlabs/bento/edit/main/website/docs/configuration/processing_pipelines.md",tags:[],version:"current",frontMatter:{title:"Processing Pipelines"},sidebar:"docs",previous:{title:"Field Paths",permalink:"/bento/docs/configuration/field_paths"},next:{title:"Unit Testing",permalink:"/bento/docs/configuration/unit_testing"}},c={},u=[];function p(e){const n={a:"a",code:"code",em:"em",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Within a Bento configuration, in between ",(0,i.jsx)(n.code,{children:"input"})," and ",(0,i.jsx)(n.code,{children:"output"}),", is a ",(0,i.jsx)(n.code,{children:"pipeline"})," section. This section describes an array of ",(0,i.jsx)(n.a,{href:"/docs/components/processors/about",children:"processors"})," that are to be applied to ",(0,i.jsx)(n.em,{children:"all"})," messages, and are not bound to any particular input or output."]}),"\n",(0,i.jsx)(n.p,{children:"If you have processors that are heavy on CPU and aren't specific to a certain input or output they are best suited for the pipeline section. It is advantageous to use the pipeline section as it allows you to set an explicit number of parallel threads of execution:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-yaml",children:"input:\n  resource: foo\n\npipeline:\n  threads: 4\n  processors:\n    - mapping: |\n        root = this\n        fans = fans.map_each(match {\n          this.obsession > 0.5 => this\n          _ => deleted()\n        })\n\noutput:\n  resource: bar\n"})}),"\n",(0,i.jsxs)(n.p,{children:["If the field ",(0,i.jsx)(n.code,{children:"threads"})," is set to ",(0,i.jsx)(n.code,{children:"-1"})," (the default) it will automatically match the number of logical CPUs available. By default almost all Bento sources will utilise as many processing threads as have been configured, which makes horizontal scaling easy."]})]})}function l(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(p,{...e})}):p(e)}},11151:function(e,n,t){t.d(n,{Z:function(){return a},a:function(){return r}});var i=t(67294);const o={},s=i.createContext(o);function r(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);