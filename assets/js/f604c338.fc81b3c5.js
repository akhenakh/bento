"use strict";(self.webpackChunkbento=self.webpackChunkbento||[]).push([[4031],{7329:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return i},default:function(){return p},frontMatter:function(){return c},metadata:function(){return l},toc:function(){return d}});var r=t(5893),o=t(1151),s=t(4866),a=t(5162);const c={title:"cached",slug:"cached",type:"processor",status:"experimental",categories:["Utility"],name:"cached"},i=void 0,l={id:"components/processors/cached",title:"cached",description:"\x3c!--",source:"@site/docs/components/processors/cached.md",sourceDirName:"components/processors",slug:"/components/processors/cached",permalink:"/bento/docs/components/processors/cached",draft:!1,unlisted:!1,editUrl:"https://github.com/warpstreamlabs/bento/edit/main/website/docs/components/processors/cached.md",tags:[],version:"current",frontMatter:{title:"cached",slug:"cached",type:"processor",status:"experimental",categories:["Utility"],name:"cached"},sidebar:"docs",previous:{title:"cache",permalink:"/bento/docs/components/processors/cache"},next:{title:"catch",permalink:"/bento/docs/components/processors/catch"}},u={},d=[{value:"Examples",id:"examples",level:2},{value:"Fields",id:"fields",level:2},{value:"<code>cache</code>",id:"cache",level:3},{value:"<code>skip_on</code>",id:"skip_on",level:3},{value:"<code>key</code>",id:"key",level:3},{value:"<code>ttl</code>",id:"ttl",level:3},{value:"<code>processors</code>",id:"processors",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.admonition,{title:"EXPERIMENTAL",type:"caution",children:(0,r.jsx)(n.p,{children:"This component is experimental and therefore subject to change or removal outside of major version releases."})}),"\n",(0,r.jsx)(n.p,{children:"Cache the result of applying one or more processors to messages identified by a key. If the key already exists within the cache the contents of the message will be replaced with the cached result instead of applying the processors. This component is therefore useful in situations where an expensive set of processors need only be executed periodically."}),"\n",(0,r.jsx)(n.p,{children:"Introduced in version 4.3.0."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yml",children:'# Config fields, showing default values\nlabel: ""\ncached:\n  cache: "" # No default (required)\n  skip_on: errored() # No default (optional)\n  key: my_foo_result # No default (required)\n  ttl: "" # No default (optional)\n  processors: [] # No default (required)\n'})}),"\n",(0,r.jsx)(n.p,{children:"The format of the data when stored within the cache is a custom and versioned schema chosen to balance performance and storage space. It is therefore not possible to point this processor to a cache that is pre-populated with data that this processor has not created itself."}),"\n",(0,r.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,r.jsxs)(s.Z,{defaultValue:"Cached Enrichment",values:[{label:"Cached Enrichment",value:"Cached Enrichment"},{label:"Periodic Global Enrichment",value:"Periodic Global Enrichment"}],children:[(0,r.jsxs)(a.Z,{value:"Cached Enrichment",children:[(0,r.jsxs)(n.p,{children:["In the following example we want to we enrich messages consumed from Kafka with data specific to the origin topic partition, we do this by placing an ",(0,r.jsx)(n.code,{children:"http"})," processor within a ",(0,r.jsx)(n.code,{children:"branch"}),", where the HTTP URL contains interpolation functions with the topic and partition in the path."]}),(0,r.jsxs)(n.p,{children:["However, it would be inefficient to make this HTTP request for every single message as the result is consistent for all data of a given topic partition. We can solve this by placing our enrichment call within a ",(0,r.jsx)(n.code,{children:"cached"})," processor where the key contains the topic and partition, resulting in messages that originate from the same topic/partition combination using the cached result of the prior."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'pipeline:\n  processors:\n    - branch:\n        processors:\n          - cached:\n              key: \'${! meta("kafka_topic") }-${! meta("kafka_partition") }\'\n              cache: foo_cache\n              processors:\n                - mapping: \'root = ""\'\n                - http:\n                    url: http://example.com/enrichment/${! meta("kafka_topic") }/${! meta("kafka_partition") }\n                    verb: GET\n        result_map: \'root.enrichment = this\'\n\ncache_resources:\n  - label: foo_cache\n    memory:\n      # Disable compaction so that cached items never expire\n      compaction_interval: ""\n'})})]}),(0,r.jsxs)(a.Z,{value:"Periodic Global Enrichment",children:[(0,r.jsxs)(n.p,{children:["In the following example we enrich all messages with the same data obtained from a static URL with an ",(0,r.jsx)(n.code,{children:"http"})," processor within a ",(0,r.jsx)(n.code,{children:"branch"}),". However, we expect the data from this URL to change roughly every 10 minutes, so we configure a ",(0,r.jsx)(n.code,{children:"cached"})," processor with a static key (since this request is consistent for all messages) and a TTL of ",(0,r.jsx)(n.code,{children:"10m"}),"."]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"pipeline:\n  processors:\n    - branch:\n        request_map: 'root = \"\"'\n        processors:\n          - cached:\n              key: static_foo\n              cache: foo_cache\n              ttl: 10m\n              processors:\n                - http:\n                    url: http://example.com/get/foo.json\n                    verb: GET\n        result_map: 'root.foo = this'\n\ncache_resources:\n  - label: foo_cache\n    memory: {}\n"})})]})]}),"\n",(0,r.jsx)(n.h2,{id:"fields",children:"Fields"}),"\n",(0,r.jsx)(n.h3,{id:"cache",children:(0,r.jsx)(n.code,{children:"cache"})}),"\n",(0,r.jsx)(n.p,{children:"The cache resource to read and write processor results from."}),"\n",(0,r.jsxs)(n.p,{children:["Type: ",(0,r.jsx)(n.code,{children:"string"})]}),"\n",(0,r.jsx)(n.h3,{id:"skip_on",children:(0,r.jsx)(n.code,{children:"skip_on"})}),"\n",(0,r.jsx)(n.p,{children:"A condition that can be used to skip caching the results from the processors."}),"\n",(0,r.jsxs)(n.p,{children:["Type: ",(0,r.jsx)(n.code,{children:"string"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yml",children:"# Examples\n\nskip_on: errored()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"key",children:(0,r.jsx)(n.code,{children:"key"})}),"\n",(0,r.jsxs)(n.p,{children:["A key to be resolved for each message, if the key already exists in the cache then the cached result is used, otherwise the processors are applied and the result is cached under this key. The key could be static and therefore apply generally to all messages or it could be an interpolated expression that is potentially unique for each message.\nThis field supports ",(0,r.jsx)(n.a,{href:"/docs/configuration/interpolation#bloblang-queries",children:"interpolation functions"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Type: ",(0,r.jsx)(n.code,{children:"string"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yml",children:'# Examples\n\nkey: my_foo_result\n\nkey: ${! this.document.id }\n\nkey: ${! meta("kafka_key") }\n\nkey: ${! meta("kafka_topic") }\n'})}),"\n",(0,r.jsx)(n.h3,{id:"ttl",children:(0,r.jsx)(n.code,{children:"ttl"})}),"\n",(0,r.jsxs)(n.p,{children:["An optional expiry period to set for each cache entry. Some caches only have a general TTL and will therefore ignore this setting.\nThis field supports ",(0,r.jsx)(n.a,{href:"/docs/configuration/interpolation#bloblang-queries",children:"interpolation functions"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Type: ",(0,r.jsx)(n.code,{children:"string"})]}),"\n",(0,r.jsx)(n.h3,{id:"processors",children:(0,r.jsx)(n.code,{children:"processors"})}),"\n",(0,r.jsx)(n.p,{children:"The list of processors whose result will be cached."}),"\n",(0,r.jsxs)(n.p,{children:["Type: ",(0,r.jsx)(n.code,{children:"array"})]})]})}function p(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},5162:function(e,n,t){t.d(n,{Z:function(){return a}});t(7294);var r=t(6010),o={tabItem:"tabItem_Ymn6"},s=t(5893);function a(e){let{children:n,hidden:t,className:a}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,r.Z)(o.tabItem,a),hidden:t,children:n})}},4866:function(e,n,t){t.d(n,{Z:function(){return k}});var r=t(7294),o=t(6010),s=t(2466),a=t(6550),c=t(469),i=t(1980),l=t(7392),u=t(12);function d(e){var n,t;return null!=(n=null==(t=r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}function h(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=null!=n?n:function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:o}}=e;return{value:n,label:t,attributes:r,default:o}}))}(t);return function(e){const n=(0,l.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function p(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const o=(0,a.k6)(),s=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,i._X)(s),(0,r.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(o.location.search);n.set(s,e),o.replace({...o.location,search:n.toString()})}),[s,o])]}function f(e){const{defaultValue:n,queryString:t=!1,groupId:o}=e,s=h(e),[a,i]=(0,r.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:r}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+r.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const o=null!=(n=r.find((e=>e.default)))?n:r[0];if(!o)throw new Error("Unexpected error: 0 tabValues");return o.value}({defaultValue:n,tabValues:s}))),[l,d]=m({queryString:t,groupId:o}),[f,b]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[o,s]=(0,u.Nk)(t);return[o,(0,r.useCallback)((e=>{t&&s.set(e)}),[t,s])]}({groupId:o}),x=(()=>{const e=null!=l?l:f;return p({value:e,tabValues:s})?e:null})();(0,c.Z)((()=>{x&&i(x)}),[x]);return{selectedValue:a,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:s}))throw new Error("Can't select invalid tab value="+e);i(e),d(e),b(e)}),[d,b,s]),tabValues:s}}var b=t(2389),x={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"},g=t(5893);function v(e){let{className:n,block:t,selectedValue:r,selectValue:a,tabValues:c}=e;const i=[],{blockElementScrollPositionUntilNextRender:l}=(0,s.o5)(),u=e=>{const n=e.currentTarget,t=i.indexOf(n),o=c[t].value;o!==r&&(l(n),a(o))},d=e=>{var n;let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{var r;const n=i.indexOf(e.currentTarget)+1;t=null!=(r=i[n])?r:i[0];break}case"ArrowLeft":{var o;const n=i.indexOf(e.currentTarget)-1;t=null!=(o=i[n])?o:i[i.length-1];break}}null==(n=t)||n.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":t},n),children:c.map((e=>{let{value:n,label:t,attributes:s}=e;return(0,g.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>i.push(e),onKeyDown:d,onClick:u,...s,className:(0,o.Z)("tabs__item",x.tabItem,null==s?void 0:s.className,{"tabs__item--active":r===n}),children:null!=t?t:n},n)}))})}function y(e){let{lazy:n,children:t,selectedValue:o}=e;const s=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=s.find((e=>e.props.value===o));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:s.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==o})))})}function j(e){const n=f(e);return(0,g.jsxs)("div",{className:(0,o.Z)("tabs-container",x.tabList),children:[(0,g.jsx)(v,{...e,...n}),(0,g.jsx)(y,{...e,...n})]})}function k(e){const n=(0,b.Z)();return(0,g.jsx)(j,{...e,children:d(e.children)},String(n))}},1151:function(e,n,t){t.d(n,{Z:function(){return c},a:function(){return a}});var r=t(7294);const o={},s=r.createContext(o);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);