"use strict";(self.webpackChunkbento=self.webpackChunkbento||[]).push([[6689],{7719:function(e,n,t){t.r(n),t.d(n,{assets:function(){return u},contentTitle:function(){return l},default:function(){return f},frontMatter:function(){return i},metadata:function(){return c},toc:function(){return d}});var r=t(5893),s=t(1151),a=t(4866),o=t(5162);const i={title:"Windowed Processing",description:"Learn how to process periodic windows of messages with Bento"},l=void 0,c={id:"configuration/windowed_processing",title:"Windowed Processing",description:"Learn how to process periodic windows of messages with Bento",source:"@site/docs/configuration/windowed_processing.md",sourceDirName:"configuration",slug:"/configuration/windowed_processing",permalink:"/bento/docs/configuration/windowed_processing",draft:!1,unlisted:!1,editUrl:"https://github.com/warpstreamlabs/bento/edit/main/website/docs/configuration/windowed_processing.md",tags:[],version:"current",frontMatter:{title:"Windowed Processing",description:"Learn how to process periodic windows of messages with Bento"},sidebar:"docs",previous:{title:"Message Batching",permalink:"/bento/docs/configuration/batching"},next:{title:"Metadata",permalink:"/bento/docs/configuration/metadata"}},u={},d=[{value:"Creating Windows",id:"creating-windows",level:2},{value:"Grouping",id:"grouping",level:2},{value:"Aggregating",id:"aggregating",level:2}];function h(e){const n={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:'A window is a batch of messages made with respect to time, with which we are able to perform processing that can analyse or aggregate the messages of the window. This is useful in stream processing as the dataset is never "complete", and therefore in order to perform analysis against a collection of messages we must do so by creating a continuous feed of windows (collections), where our analysis is made against each window.'}),"\n",(0,r.jsx)(n.p,{children:"For example, given a stream of messages relating to cars passing through various traffic lights:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "traffic_light": "cbf2eafc-806e-4067-9211-97be7e42cee3",\n  "created_at": "2021-08-07T09:49:35Z",\n  "registration_plate": "AB1C DEF",\n  "passengers": 3\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"Windowing allows us to produce a stream of messages representing the total traffic for each light every hour:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-json",children:'{\n  "traffic_light": "cbf2eafc-806e-4067-9211-97be7e42cee3",\n  "created_at": "2021-08-07T10:00:00Z",\n  "unique_cars": 15,\n  "passengers": 43\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"creating-windows",children:"Creating Windows"}),"\n",(0,r.jsx)(n.p,{children:"The first step in processing windows is producing the windows themselves, this can be done by configuring a window producing buffer after your input:"}),"\n","\n","\n",(0,r.jsx)(a.Z,{defaultValue:"system",values:[{label:"System Clock",value:"system"}],children:(0,r.jsxs)(o.Z,{value:"system",children:[(0,r.jsxs)(n.p,{children:["A ",(0,r.jsxs)(n.a,{href:"/docs/components/buffers/system_window",children:[(0,r.jsx)(n.code,{children:"system_window"})," buffer"]})," creates windows by following the system clock of the running machine. Windows will be created and emitted at predictable times, but this also means windows for historic data will not be emitted and therefore prevents backfills of traffic data:"]}),(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:"input:\n  kafka:\n    addresses: [ TODO ]\n    topics: [ traffic_data ]\n    consumer_group: traffic_consumer\n    checkpoint_limit: 1000\n\nbuffer:\n  system_window:\n    timestamp_mapping: root = this.created_at\n    size: 1h\n    allowed_lateness: 3m\n"})}),(0,r.jsxs)(n.p,{children:["For more information about this buffer refer to ",(0,r.jsxs)(n.a,{href:"/docs/components/buffers/system_window",children:["the ",(0,r.jsx)(n.code,{children:"system_window"})," buffer docs"]}),"."]})]})}),"\n",(0,r.jsx)(n.h2,{id:"grouping",children:"Grouping"}),"\n",(0,r.jsxs)(n.p,{children:["With a window buffer chosen our stream of messages will be emitted periodically as batches of all messages that fit within each window. Since we want to analyse the window separately for each traffic light we need to expand this single batch out into one for each traffic light identifier within the window. For that purpose we have two processor options: ",(0,r.jsx)(n.a,{href:"/docs/components/processors/group_by",children:(0,r.jsx)(n.code,{children:"group_by"})})," and ",(0,r.jsx)(n.a,{href:"/docs/components/processors/group_by_value",children:(0,r.jsx)(n.code,{children:"group_by_value"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["In our case we want to group by the value of the field ",(0,r.jsx)(n.code,{children:"traffic_light"})," of each message, which we can do with the following:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'pipeline:\n  processors:\n    - group_by_value:\n        value: ${! json("traffic_light") }\n'})}),"\n",(0,r.jsx)(n.h2,{id:"aggregating",children:"Aggregating"}),"\n",(0,r.jsxs)(n.p,{children:["Once our window has been grouped the next step is to calculate the aggregated passenger and unique cars counts. For this purpose the Bento ",(0,r.jsx)(n.a,{href:"/docs/guides/bloblang/about",children:"mapping language Bloblang"})," comes in handy as the method ",(0,r.jsx)(n.a,{href:"/docs/guides/bloblang/methods#from_all",children:(0,r.jsx)(n.code,{children:"from_all"})})," executes the target function against the entire batch and returns an array of the values, allowing us to mutate the result with chained methods such as ",(0,r.jsx)(n.a,{href:"/docs/guides/bloblang/methods#sum",children:(0,r.jsx)(n.code,{children:"sum"})}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-yaml",children:'pipeline:\n  processors:\n    - group_by_value:\n        value: ${! json("traffic_light") }\n\n    - mapping: |\n        let is_first_message = batch_index() == 0\n\n        root.traffic_light = this.traffic_light\n        root.created_at = @window_end_timestamp\n        root.total_cars = if $is_first_message {\n          json("registration_plate").from_all().unique().length()\n        }\n        root.passengers = if $is_first_message {\n          json("passengers").from_all().sum()\n        }\n\n        # Only keep the first batch message containing the aggregated results.\n        root = if ! $is_first_message {\n          deleted()\n        }\n'})}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.a,{href:"/docs/guides/bloblang/about",children:"Bloblang"})," is very powerful, and by using ",(0,r.jsx)(n.a,{href:"/docs/guides/bloblang/methods#from",children:(0,r.jsx)(n.code,{children:"from"})})," and ",(0,r.jsx)(n.a,{href:"/docs/guides/bloblang/methods#from_all",children:(0,r.jsx)(n.code,{children:"from_all"})})," it's possible to perform a wide range of batch-wide processing. If you fancy a challenge try updating the above mapping to only count passengers from the first journey of each registration plate in the window (hint: the ",(0,r.jsxs)(n.a,{href:"/docs/guides/bloblang/methods#fold",children:[(0,r.jsx)(n.code,{children:"fold"})," method"]})," might come in handy)."]})]})}function f(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},5162:function(e,n,t){t.d(n,{Z:function(){return o}});t(7294);var r=t(6010),s={tabItem:"tabItem_Ymn6"},a=t(5893);function o(e){let{children:n,hidden:t,className:o}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,r.Z)(s.tabItem,o),hidden:t,children:n})}},4866:function(e,n,t){t.d(n,{Z:function(){return j}});var r=t(7294),s=t(6010),a=t(2466),o=t(6550),i=t(469),l=t(1980),c=t(7392),u=t(12);function d(e){var n,t;return null!=(n=null==(t=r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}function h(e){const{values:n,children:t}=e;return(0,r.useMemo)((()=>{const e=null!=n?n:function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:r,default:s}}=e;return{value:n,label:t,attributes:r,default:s}}))}(t);return function(e){const n=(0,c.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function f(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function g(e){let{queryString:n=!1,groupId:t}=e;const s=(0,o.k6)(),a=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,l._X)(a),(0,r.useCallback)((e=>{if(!a)return;const n=new URLSearchParams(s.location.search);n.set(a,e),s.replace({...s.location,search:n.toString()})}),[a,s])]}function p(e){const{defaultValue:n,queryString:t=!1,groupId:s}=e,a=h(e),[o,l]=(0,r.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:r}=e;if(0===r.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!f({value:t,tabValues:r}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+r.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const s=null!=(n=r.find((e=>e.default)))?n:r[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:n,tabValues:a}))),[c,d]=g({queryString:t,groupId:s}),[p,m]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[s,a]=(0,u.Nk)(t);return[s,(0,r.useCallback)((e=>{t&&a.set(e)}),[t,a])]}({groupId:s}),b=(()=>{const e=null!=c?c:p;return f({value:e,tabValues:a})?e:null})();(0,i.Z)((()=>{b&&l(b)}),[b]);return{selectedValue:o,selectValue:(0,r.useCallback)((e=>{if(!f({value:e,tabValues:a}))throw new Error("Can't select invalid tab value="+e);l(e),d(e),m(e)}),[d,m,a]),tabValues:a}}var m=t(2389),b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"},w=t(5893);function v(e){let{className:n,block:t,selectedValue:r,selectValue:o,tabValues:i}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,a.o5)(),u=e=>{const n=e.currentTarget,t=l.indexOf(n),s=i[t].value;s!==r&&(c(n),o(s))},d=e=>{var n;let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{var r;const n=l.indexOf(e.currentTarget)+1;t=null!=(r=l[n])?r:l[0];break}case"ArrowLeft":{var s;const n=l.indexOf(e.currentTarget)-1;t=null!=(s=l[n])?s:l[l.length-1];break}}null==(n=t)||n.focus()};return(0,w.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":t},n),children:i.map((e=>{let{value:n,label:t,attributes:a}=e;return(0,w.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>l.push(e),onKeyDown:d,onClick:u,...a,className:(0,s.Z)("tabs__item",b.tabItem,null==a?void 0:a.className,{"tabs__item--active":r===n}),children:null!=t?t:n},n)}))})}function x(e){let{lazy:n,children:t,selectedValue:s}=e;const a=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=a.find((e=>e.props.value===s));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return(0,w.jsx)("div",{className:"margin-top--md",children:a.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function y(e){const n=p(e);return(0,w.jsxs)("div",{className:(0,s.Z)("tabs-container",b.tabList),children:[(0,w.jsx)(v,{...e,...n}),(0,w.jsx)(x,{...e,...n})]})}function j(e){const n=(0,m.Z)();return(0,w.jsx)(y,{...e,children:d(e.children)},String(n))}},1151:function(e,n,t){t.d(n,{Z:function(){return i},a:function(){return o}});var r=t(7294);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);